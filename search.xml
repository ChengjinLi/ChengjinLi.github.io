<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[词向量简介]]></title>
    <url>%2F2017%2F11%2F01%2Fword-vector-abstract%2F</url>
    <content type="text"><![CDATA[简介自然语言是一套用来表达含义的复杂系统。在这套系统中，词是表义的基本单元。在 NLP 领域中，如何量化词的表达也是关键问题之一。用某个固定维度的向量(vector)去表示词是一个很经典很基本的任务，我们称这个向量为「词向量」，通常也被认为是词的特征向量。我们之所以要把单词变成向量是因为我们需要把自然语言抽象成数学中的某个概念（这里是向量）。换一种更具体直白的说法，之所以要把单词变成固定维度的向量，是因为绝大多数的机器学习(Machine Learning)模型需要固定维度的向量作为输入。近年来，「词向量」已逐渐成为自然语言处理的基础知识，一份高质量的「词向量」是很多任务取得更好表现的关键。常见的方式有以下两种： 独热编码(One-Hot Encoding) 词嵌入(Word Embedding) 独热编码(One-Hot Encoding)独热编码即 One-Hot 编码，又称一位有效编码，直观来说就是使用 N 位状态寄存器对 N 个状态进行编码，每个状态都有其独立的寄存器位，并且在任意时候有且只有一位有效，即只有一个值为 1，其他值全为 0 的一种码制。在机器学习的任务中，对于离散型的分类型的数据，需要对其进行数字化，比如说「性别」这一属性，只能有「男性」、「女性」或者「其他」这三种值，如何对这三个值进行数字化表达呢？一种简单的方式就是「男性」为 0，「女性」为 1，「其他」为 2。使用上面简单的方式对分类值进行数字化后，进行模型训练时可能会产生一个问题：特征因为数字值的不同影响模型的训练效果，在模型训练的过程中不同的值使得同一特征在样本中的权重可能发生变化。假如直接编码成 100，是不是比编码成 1 对模型的的影响更大？为了解决上述的问题，使训练过程中不受到因为分类值数字化的问题对模型产生的负面影响，引入独热码对分类型的特征进行独热码编码。 在 NLP 任务中，假设词典中不同词的数量为 N，每个词的 index 都与 0 到 N-1 的连续整数一一对应。假设一个词的下标为 i，为了得到该词的 One-Hot 向量表示，我们创建一个全 0 的长为 N的向量，并将其第 i位置成 1。One-Hot 编码使用了高维稀疏向量表示词，这样的特征可以反映词出现的频率，但这并不是最好的选择。一个主要的原因是，One-Hot 词向量无法表达不同词之间的关系，例如「相似度」这一度量关系。任何一对词的 One-Hot 向量的余弦相似度都为 0。 那究竟用什么向量去表示词才是合理的呢？一个符合直觉的想法是，相似的词应该有相似的「词向量」，比如 dog 和 cat 这两个词，他们的意思很相近，那么他们的「词向量」也应该很相似，或者说他们的「词向量」在空间中位置很接近，距离很短。再比如 dog 和 rocket 这两个词，他们的「词向量」在空间中位置应该距离比较远。我们应该怎样做才能使得相似的词有相似的「词向量」呢？ 词嵌入(Word Embedding)目前大多数人所述的「词向量」，其实指的就是「词嵌入」。与 One-Hot 编码相比而言，「词嵌入」技术将词汇的上下文关系嵌入到一个低维空间。举一个简单的例子，在字典用我们会用几千个常用词去解释每个词的意思，而「词向量」中，我们用(比如) 100 维的实数向量去表示字典中的词。换一种说法，我们要把字典中每一个词映射到某个维度(比如 100 维)的空间当中去，所以我们也可以把「词向量」叫做「空间向量模型」(Vector Space Model)。「词嵌入」模型几乎都利用了语言学中这样的一个规律：相似的词有着相似的上下文。这个规律叫 Distributional Hypothesis。原理基本都是词的上下文的分布可以揭示这个词的语义，就好比“看看你跟什么样的人交往，就知道你是什么样的人”，所以「词向量」模型的核心就是对上下文的关系进行建模。还是以 dog 和 cat 两个词为例，他们是比较相似的单词，他们在语料中的上下文也很相近。他们的上下文中一般都会出现关于动物、宠物的单词或短语。所以，目前主流的「词向量」模型表面上千差万别，但是本质都很相似，都是对词与其上下文的关系进行建模，从而得到高质量的「词向量」。目前比较有代表性的工具有 word2vec、GloVe 和 fastText 等。 词类比(Word Analogy)上面已经提到，「词向量」会把相似的词映射到空间中相近的位置中去。所以我们可以用「词向量」找到和某个词相近的词。除此之外，「词向量」还有另一个比较优美的性质，「词类比」(Word Analogy)。在词类比任务中，我们需要通过前三个单词，例如 Athens、Greece、Baghdad，推导出第四个单词 Iraq。推导的过程就是「雅典」和「希腊」是首都的关系，「巴格达」和谁是首都的关系？答案是「伊拉克」。要做好这个任务，就要求我们还需要从「词向量」中得到词之间关系的信息，比如在上述例子中，这个关系就是「首都」。当年 word2vec 出现以后受到大家广泛关注，一个可能的原因就是大家惊讶于「词向量」能在 Word Analogy数据集上取得这么好的效果，原来「词向量」还有这样神奇的性质。 那「词向量」为何有能力做好 Word Analogy 这个任务呢？在 word2vec 中用 vec(&#39;wife&#39;) + vec(&#39;king&#39;) - vec(&#39;queen&#39;) 去寻找 husband 这个词，这种加加减减的操作看似没有什么道理，这里先给一个例子帮助大家直观的理解。我们以 king、queen 这两个词为例。假设语料中 king 周围出现的词主要和「皇室」这个主题以及「男性」这个主题有关。queen 周围出现的词主要和「皇室」这个主题和「女性」这个主题有关。我们令 vec(&#39;皇室&#39;)为所有有关「皇室」主题的词的「词向量」的平均，vec(&#39;男性&#39;) 和 vec(&#39;女性&#39;) 分别为所有有关「男性」和「女性」主题的词的「词向量」的平均。我们在上面内容中提到过，词的语义能通过它在语料中的上下文中的信息体现出来。我们这里就认为 vec(&#39;king&#39;) = 1/2(vec(&#39;皇室&#39;) + vec(&#39;男性&#39;))，vec(&#39;queen&#39;) = 1/2(vec(&#39;皇室&#39;) + vec(&#39;女性&#39;))。所以 vec(&#39;king&#39;) - vec(&#39;queen&#39;) 就等于 1/2(vec(&#39;男性&#39;)-vec(&#39;女性&#39;))。同理，对于 husband、wife 这两个词，husband 周围的词是关于「伴侣」和「男性」的主题，wife 周围的词是关于「伴侣」和「女性」的主题。vec(&#39;husband&#39;) - vec(&#39;wife&#39;) 同样等于1/2(vec(&#39;男性&#39;)- vec(&#39;女性&#39;)) 。这样 vec(&#39;husband&#39;) - vec(&#39;wife&#39;) 就等于vec(&#39;king&#39;) - vec(&#39;queen&#39;) ，我们就能轻易的通过三个词，去推断出第四个词。而 vec(&#39;king&#39;) - vec(&#39;queen&#39;) 也很好的反映了「男性」与「女性」这样一个关系。 总结在之后的「词向量」系列博文中，我会全面细致的解析包括 word2vec、GloVe 和 fastText 等一系列「词向量」工具包。通过上面提到的工具包，我们可以得到高质量的「词向量」，也可以根据我们的需求，得到不同性质的「词向量」]]></content>
      <categories>
        <category>词向量</category>
      </categories>
      <tags>
        <tag>词向量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记---map容器使用教程]]></title>
    <url>%2F2017%2F10%2F27%2Fcpp-container-map-use-tutorial%2F</url>
    <content type="text"><![CDATA[注意事项: 在map中，由key查找value时，首先要判断map中是否包含key。 如果不检查，直接返回map[key]，可能会出现意想不到的行为。如果map包含key，没有问题，如果map不包含key，使用下标有一个危险的副作用，会在map中插入一个key的元素，value取默认值，返回value。也就是说，map[key]不可能返回null。 map提供了两种方式，查看是否包含key，map.count(key)、map.find(key)。 map.count(key)：由于map不包含重复的key，因此map.count(key)取值为0，表示不包含，取值为1，表示包含。 map.find(key)：返回迭代器，判断是否存在。 对于STL中的容器，有泛型算法find(begin，end，target)查找目标，map还提供了一个成员方法find(key)。 对于下面的场景，存在key就使用，否则返回null，有下面两种写法：1234if(1 == map.count(key)) &#123; return map[key];&#125;return null; 12345iter = map.find(key);if(iter != map.end()) &#123; return iter-&gt;second;&#125;return null; 这里需要注意：前一种方法很直观，但是效率差很多。因为前面的方法，需要执行两次查找。因此，推荐使用后一种方法。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++,container</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记---vector容器使用教程]]></title>
    <url>%2F2017%2F10%2F21%2Fcpp-container-vector-use-tutorial%2F</url>
    <content type="text"><![CDATA[利用 remove_if() 和 erase() 从 vector 中移除指定 set 中包含的元素 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_set&gt;std::unordered_set&lt;std::string&gt; replace_str_set&#123;",", "."&#125;;bool IsReplaceStr(std::string str) &#123; if (replace_str_set.find(str) != replace_str_set.end()) &#123; return true; &#125; return false;&#125;int main() &#123; std::vector&lt;std::string&gt; string_vector&#123;"a", ",", "b", ".", "c"&#125;; std::vector&lt;std::string&gt;::iterator it; std::cout &lt;&lt; "before replace: "; for (it = string_vector.begin(); it != string_vector.end(); it++) &#123; std::cout &lt;&lt; *it; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; std::endl; string_vector.erase(remove_if(string_vector.begin(), string_vector.end(), IsReplaceStr), string_vector.end()); std::cout &lt;&lt; "after replace: "; for (it = string_vector.begin(); it != string_vector.end(); it++) &#123; std::cout &lt;&lt; *it; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出结果：12before replace: a,b.cafter replace: abc]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++,container</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记---容器(container)使用教程]]></title>
    <url>%2F2017%2F10%2F20%2Fcpp-container-use-tutorial%2F</url>
    <content type="text"><![CDATA[在 C++ 的 STL 中，常见的容器可分为「顺序容器」(sequential container) 和「关联容器」(associative container)。 标准的 STL 「顺序容器」包括： vector、deque、list、forward_list、array 与 string。 标准的 STL「关联容器」可分为「关键字有序」和「关键字无序」。 关键字有序：map、set、multimap和multiset。 关键字无序： unorder_map、unorder_set、unorder_multimap和unorder_multiset。 vectorvector将元素保存在连续的内存空间中，支持随机存取。由于元素是连续存储的，在这两种容器中间插入和删除元素，需要修改该位置之后所有元素的位置，效率较低。如果不清楚元素的确切个数，请使用vector，如果清楚元素的确切个数，请使用数组。 string、string将元素保存在连续的内存空间中，支持随机存取。由于元素是连续存储的，在这两种容器中间插入和删除元素，需要修改该位置之后所有元素的位置，效率较低。 list、forward_listlist和forward_list分别对应数据结构中的双向链表和单向链表。两个容器将元素的设计目的是让容器在任何位置的插入和删除效率提高，但其代价是容器不支持随机存取，查找效率较低。 dequedeque是一种更为复杂的数据结构。与string和vector类似，支持快速随机访问，并且在其两端添加和删除元素的效率都很高。但是，由于deque中元素也是连续存储，在其中间插入和删除元素的效率也较低。 arrayarray是一种更安全的数组，与内置数组类似，不支持动态内存分配，支持元素随机访问。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++,container</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow Tensor变换API]]></title>
    <url>%2F2017%2F10%2F19%2Ftensorflow-tensor-transform-api%2F</url>
    <content type="text"><![CDATA[tf.stack()12345stack( values, axis=0, name=&quot;stack&quot;) 官方文档： https://www.tensorflow.org/api_docs/python/tf/stack 定义： tensorflow/python/ops/array_ops.py 功能： 将由 R 维的 tensor 堆成 R+1 维的 tensor . 说明： 通过沿着 axis 维，将 values 中的 tensor 列表填充到一个比values 中的 tensor 高一维的 tensor中。 给定一个长度为 N ，由 shape 为 （A，B，C） 的 tensor 构成的列表； 如果 axis == 0，输出的 tensor 的 shape 为 (N, A, B, C) 如果 axis == 1，输出的 tensor 的 shape 为 (A, N, B, C) 示例：12345678910111213141516171819import tensorflow as tfx = [1, 4]y = [2, 5]z = [3, 6]stack_0 = tf.stack([x, y, z])print (stack_0.get_shape()) # (3, 2)stack_1 = tf.stack([x, y, z], axis=1)print (stack_1.get_shape()) # (2, 3)with tf.Session() as sess: stack_0_val, stack_1_val = sess.run([stack_0, stack_1]) print ('stack_0_val:') print (stack_0_val) # [[1, 4], [2, 5], [3, 6]] print ('stack_0_val.shape: %s' % str(stack_0_val.shape)) # (3, 2) print ('stack_1_val:') print (stack_1_val) # [[1, 2, 3], [4, 5, 6]] print ('stack_1_val.shape: %s' % str(stack_1_val.shape)) # (2, 3) 输出结果：1234567891011stack_0.get_shape(): (3, 2)stack_1.get_shape(): (2, 3)stack_0_val:[[1 4] [2 5] [3 6]]stack_0_val.shape: (3, 2)stack_1_val:[[1 2 3] [4 5 6]]stack_1_val.shape: (2, 3)]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow的2种安装方法---pip安装和源码安装]]></title>
    <url>%2F2017%2F10%2F01%2Ftensorflow-install%2F</url>
    <content type="text"><![CDATA[本篇学习笔记是在 macOS 系统上进行的演示，python 版本为 2.7.10，如果大家想学习在 windows，linux 等系统上的安装步骤，可以参考一下官方的安装 TensorFlow 的方法：https://www.tensorflow.org/install/ ，个人建议在虚拟环境下安装 TensorFlow。下面介绍 TensorFlow 的2种安装方法。 通过「pip」直接安装安装「pip」如果已经安装，跳过此步1sudo easy_install pip 查看 pip 是否安装成功1pip —version 安装「tensorflow」安装CPU版本:1pip install tensorflow 安装GPU版本：1pip install tensorflow-gpu 注：默认安装都是最新版本，如需要安装指定版本，需要加上版本号例如安装1.0.0版本安装CPU版本:1pip install tensorflow==1.0.0 安装GPU版本:1pip install tensorflow-gpu==1.0.0 通过源码安装首先Mac下内置有gcc，可以通过终端命令gcc -v 查看： 其中的4.2.1就是gcc的版本，或者大家也可以直接输入终端命令python进行查看 里面有一个GCC 4.2.1，感觉比上面那个命令更直观一些。然后就是要安装Google自家的编译工具bazel了，mac上最好的办法就是直接使用brew安装了：\brew install bazel安装好之后就要下载官方的TensorFlow源码了：git clone https://github.com/tensorflow/tensorflow下载完成后会在你的用户名的目录下生成一个tensorflow的文件夹，使用cd tensorflow进入这个文件夹，然后输入：./configure进行配置，通常情况下没有特殊的要求，一般全部都选择n，需要输入path的地方敲回车，使用默写path 配置完成后就是编译过程了，输入终端命令:bazel build –config=opt //tensorflow/tools/pip_package:build_pip_package经过漫长的编译后，任务就基本上完成了，接下来就是输入下面的命令来生成pip安装包了：bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg接下来安装这个wheel。如果之前pip装过tf的话，最好先卸载掉：pip uninstall tensorflow再安装pip install /tmp/tensorflow_pkg/tensorflow-1.3.0-cp27-cp27m-macosx_10_12_intel.whl安装成功Installing collected packages: tensorflowSuccessfully installed tensorflow-1.2.0验证安装遇到的问题：如果错误是bazel相关的，请卸载bazel重新安装。]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python虚拟环境---virtualenv的安装及使用]]></title>
    <url>%2F2017%2F08%2F10%2Fvirtualenv-using-tutorial%2F</url>
    <content type="text"><![CDATA[在开发 Python 应用程序的时候，系统安装的 Python只有一个版本，所有第三方的包都会被 pip 安装到 Python 的 site-packages 目录下。如果我们要同时开发多个应用程序，那这些应用程序都会共用这个安装在系统的 Python。如果 「应用A」 需要 Python 2.6 版本，而 「应用B」 需要 Python 2.7 版本，这种情况下共用这个安装在系统的 Python 版本就不能满足需求了，每个应用需要各自拥有一套「独立」的 Python 运行环境。virtualenv 就是用来为一个应用创建一套「独立」的 Python 运行环境，在虚拟环境下，用 pip 安装的包都被安装到虚拟环境 Python 的 site-packages 下，系统 Python 环境不受任何影响。 安装「virtualenv」1sudo pip install virtualenv 查看 virtualenv 是否安装成功1virtualenv —version 创建「virtualenv」环境切换到虚拟环境要存放的目录，创建虚拟环境:1virtualenv &lt;env_name&gt; 个人建议： 虚拟环境与项目在同一目录下，并且虚拟环境以前缀 env_ 加项目名来命名。示例：machine_learning 是项目目录，env_machine_learning 是虚拟环境目录。 激活「virtualenv」环境1source &lt;env_name&gt;/bin/activate 激活成功后，命令提示符有个(&lt;env_name&gt;)前缀，表示当前环境是一个名为 &lt;env_name&gt; 的 Python 虚拟环境。 退出「virtualenv」环境1deactivate 退出成功后，命令提示符(&lt;env_name&gt;)前缀消失，此时就回到了正常的系统环境。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端复用工具---「tmux」的安装及使用]]></title>
    <url>%2F2017%2F08%2F09%2Ftmux-using-tutorial%2F</url>
    <content type="text"><![CDATA[简介tmux 是一个优秀的终端复用软件，即使非正常掉线，也能保证当前的任务运行，这一点对于远程 ssh 访问特别有用，网络不好的情况下仍然能保证工作现场不丢失! tmux 完全使用键盘控制窗口，实现窗口的切换。 安装在「Mac OS」中安装安装「Homebrew」如果没有 homebrew ，先安装 homebrew ，如果已经安装，则跳过此步。1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装「Tmux」1brew install tmux 查看是否安装成功通过如下命令查看 tmux 的版本号1tmux -V 当前安装版本为 2.6，则终端显示如下：1tmux 2.6 在「Ubuntu」中安装在终端输入如下命令：1sudo apt-get install tmux 「Tmux」的配置文件tmux 的配置文件为 ~/.tmux.conf ，每当开启一个新的会话时，tmux 都会先读取这个文件。 「Tmux」的快捷键前缀(Prefix)为了使自身的快捷键和其他软件的快捷键互不干扰， tmux 提供了一个快捷键前缀(Prefix)，默认是组合键 Ctrl-b（同时按下 Ctrl 键和 b 键）当想要使用快捷键时，需要先按下快捷键前缀，然后再按下快捷键，以下把前缀按键称为 Prefix。 下面介绍一下 tmux 的三个核心概念，会话(session)、窗口(window)和窗格(pane)及其基本用法。 会话「session」创建session创建一个新的会话，只需要在终端运行如下的命令：1tmux new -s &lt;session_name&gt; -n &lt;window_name&gt; 参数说明： -s 参数表示会话名称，如果不加 -s 参数，那么 tmux 默认会新建一个以数字(下标从 0 开始)命名的会话，并默认打开一个窗口。-n 参数表示默认打开的窗口的名称 重命名session1Prefix + $ : 重命名当前的会话 断开session想要暂时从 tmux 暂时分离，回到终端环境时，可以通过如下快捷键。1Prefix + d : 断开当前的会话 注意，即使是 detach 的状态，tmux 中在运行的程序还会继续运行 回到session想要回到 session 时，只需执行：1tmux attach -t &lt;session_name&gt; 列出session在终端下，运行如下命令列出当前有多少个会话：1tmux ls 在会话中列出当前有多少个会话1Prefix + s : 列出所有会话 关闭session在终端下，要真正关闭一个会话，可以运行如下命令：1tmux kill-session -t &lt;session_name&gt; 参数说明： -t 参数表示会话名称。 窗口「window」如果说会话是个不可见的东西，那么窗口就是我们输入、执行命令的地方。一个会话 可以包含多个会话。 创建window在创建会话的时候默认会创建一个以 数字下标+bash 命名的窗口，并且名称随着 bash 中执行的不同命令而变化。1Prefix + c : 创建一个新窗口 重命名window1Prefix + , : 重命名当前窗口 切换window同一个会话下的多个window之间切换。1234Prefix + p: 切换到上一个窗口。 Prefix + n: 切换到下一个窗口 。 Prefix + 0: 切换到0号window，依次类推，1、2、3... Prefix + w: 列出全部窗口，通过上、下键选择要进入的窗口，按回车键即可进入所选择的窗口中。 关闭window1Prefix + &amp; : 关闭当前窗口。 窗格「pane」一个窗口可以切割成多个窗格，也就是所谓的分屏。 创建pane12Prefix + % : 垂直分屏，用一条垂线把当前窗口分成左右两屏。 Prefix + &quot; : 水平分屏，用一条水平线把当前窗口分成上下两屏。 切换pane1234Prefix + o : 依次切换当前窗口下的各个窗格。 Prefix + Up|Down|Left|Right : 根据按箭方向选择切换到某个窗格。 Prefix + Space(空格键): 对当前窗口下的所有窗格重新排列布局，每按一次，换一种样式。 Prefix + z : 最大化当前窗格。再按一次后恢复。 关闭pane1Prefix + x : 关闭当前使用中的窗格。 其他pane快捷键12345Prefix + q : 显示窗格的编号Prefix + &#125; : 与下一个窗格交换位置Prefix + &#123; : 与上一个窗格交换位置Prefix + ! : 在新窗口中显示当前窗格Prefix + t : 在当前窗格显示时间 滚屏1Prefix + [ : 滚屏 滚屏要进入 copy-mode，然后就可以用上下键来滚动屏幕，配置了 vi 快捷键模式，就可以像操作 vi 一样来滚动屏幕，非常的方便。 退出直接回车键或 q键即可退出]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>linux, tmux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令教程]]></title>
    <url>%2F2017%2F08%2F05%2Fgit-command-tutorial%2F</url>
    <content type="text"><![CDATA[Git简介Git 介绍Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 什么文件可以被 Git 管理?文本文件(.txt)，脚本文件(.py等)，各种基于文本信息的文件. 什么文件不能被 Git 管理?图片文件(.jpg等)，PDF(.pdf)，MS Word(.doc)，MS Power Point(.ppt)，MS Excel(.xls)等。 Git 基础Git 直接记录快照，而非差异比较Git 和其它版本控制系统（包括 Subversion 等）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个「快照流」。这是 Git 与几乎所有其它版本控制系统的重要区别。 因此 Git 重新考虑了以前每一代版本控制系统延续下来的诸多方面。Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 VCS。 Git 不需要联网就能工作在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息，由于本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。而其他集中式版本控制系统(例如 SVN等)，必须联网才能工作， 所有操作都有网络延时开销。 Git 保证完整性Git 的内容完整性要优于其他集中式版本控制系统(例如 SVN等)。Git 中所有数据在存储前都计算校验和，然后以校验和来引用。这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若在传送过程中丢失信息或损坏文件，Git 就能发现。Git 用以计算校验和的机制叫做 SHA-1 哈希散列。 这是一个由40个十六进制字符(0-9 和 a-f)组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：24b9da6552252987aa493b52f8696cd6d3b00373，Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 Git 一般只添加数据Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。 同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。这使得在使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。 Git 安装最早 Git 是在 Linux 上开发的，很长一段时间内，Git 也只能在 Linux 和 Unix 系统上跑。目前，Git 已经可以在 Linux、Unix、Mac 和 Windows 几大平台上运行。详细的安装说明请前往 Git官网安装说明 查看， Git 在每种系统上的安装方式各不相同，安装步骤分别如下: Linux平台上安装打开 terminal，可以用下面的命令安装： Debian/Ubuntu1$ apt-get install git-all 使用 git --version 查看是否安装成功12$ git --versiongit version 2.7.4 Centos/RedHat1$ yum -y install git-all 使用 git --version 查看是否安装成功12$ git --versiongit version 1.7.1 Mac 平台上安装1、先下载 .dmg 安装包，下载地址为：https://git-scm.com/download/mac ，点击下载到本地，下载文件例如：git-2.14.1-intel-universal-mavericks.dmg2、双击安装包进行安装即可3、使用 git --version 查看是否安装成功12$ git --versiongit version 2.14.1 Windows 平台上安装1、先下载 .exe 安装包，下载地址为：https://git-scm.com/download/win ，选择适合当前系统的版本，点击下载到本地2、双击安装包进行安装即可3、在开始菜单里找到Git-&gt;Git Bash，会弹出 Git 命令窗口，使用 git --version 查看是否安装成功12$ git versiongit version 2.14.2.windows.1 Git 配置安装 Git 后，每台计算机上只需要进行一次配置，程序升级时会保留配置信息。你可以在任何时候再次通过运行命令来修改它们。Git 自带一个 git config 的工具，专门用来配置或读取相应的工作环境变量。这些变量存储在三个不同的位置： /etc/gitconfig 文件： 包含系统上每一个用户及他们仓库的通用配置，如果使用带有 --system 选项的 git config 时，它会从此文件读写配置变量。 ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户，可以传递 --global 选项让 Git 读写此文件。 当前使用仓库的 Git 目录中的 config 文件(就是 .git/config)：针对该仓库。 每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。 在 Windows 系统中，Git 会查找 $HOME 目录下（一般情况下是 C:\Users\$USER）的 .gitconfig 文件。 Git 同样也会寻找 /etc/gitconfig 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。 配置用户信息当安装完 Git 应该做的第一件事就是设置个人的「用户名称」与「邮件地址」。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：12$ git config --global user.name lichengjin$ git config --global user.email lichengjin606@gmail.com 再次强调，如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，Git 都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 --global选项的命令来配置，新的设定保存在当前项目的 .git/config 文件里。 查看配置信息要检查已有的配置信息，可以使用 git config --list 命令：123$ git config --listuser.name=lichengjinuser.email=lichengjin606@gmail.com 有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。这些配置我们也可以在 ~/.gitconfig 或 /etc/gitconfi 看到，如下所示：1$ vim ~/.gitconfig 显示内容如下所示：123[user] name = lichengjin email = lichengjin606@gmail.com 你可以通过输入 git config &lt;key&gt; 来检查 Git的某一项配置，例如：12$ git config user.namelichengjin Git 工作流程Git 的工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 下图展示了 Git 的工作流程，图片来自菜鸟教程： Git 工作区，暂存区和版本库工作区：就是你在电脑里能看到的目录。是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。暂存区：英文叫stage， 或index。是一个文件，一般存放在 .git/index 中，保存了下次将提交的文件列表信息，有时候也被称作索引( index )。版本库：版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原。工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库，是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。下面这个图展示了「工作区」、「暂存区」和「版本库」之间的关系，图片来自菜鸟教程：图中左侧为「工作区」，右侧为「版本库」。在「版本库」中标记为 index 的区域是「暂存区」(stage，index)，标记为 master 的是 master 分支所代表的目录树。图中我们可以看出此时 HEAD 实际是指向 master 分支的一个「游标」。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。图中的 objects 标识的区域为 Git 的「对象库」，实际位于 .git/objects 目录下，里面包含了创建的各种对象及内容。当对「工作区」修改或新增的文件执行 git add 命令时，「暂存区」的目录树被更新，同时「工作区」修改或新增的文件内容被写入到「对象库」中的一个新的对象中，而该对象的 ID 被记录在暂存区的文件索引中。当执行提交操作 git commit 时，「暂存区」的目录树写到「版本库」中，master 分支会做相应的更新。即 master 指向的目录树就是提交时「暂存区」的目录树。当执行 git reset HEAD 命令时，「暂存区」的目录树会被重写，被 master 分支指向的目录树所替换，但是「工作区」不受影响。当执行 git rm --cached &lt;file&gt; 命令时，会直接从「暂存区」删除文件，「工作区」则不做出改变。当执行 git checkout . 或者 git checkout -- &lt;file&gt; 命令时，会用「暂存区」全部或指定的文件替换「工作区」的文件。这个操作很危险，会清除「工作区」中未添加到「暂存区」的改动。当执行 git checkout HEAD . 或者 git checkout HEAD &lt;file&gt; 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换「暂存区」和以及「工作区」中的文件。这个命令也是极具危险性的，因为不但会清除「工作区」中未提交的改动，也会清除「暂存区」中未提交的改动。 获取版本库创建新的版本库1、 选择一个合适的地方，创建一个空目录： 1234$ mkdir git_tutorial$ cd git_tutorial$ pwd/Users/lichengjin/workspace/git_tutorial 2、 通过 git init 命令把这个目录变成 Git 可以管理的仓库:注：如果打算使用 Git 来对现有的项目进行管理，只需要进入该项目目录并输入git init。 12$ git initInitialized empty Git repository in /Users/lichengjin/workspace/git_tutorial/.git/ 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干，是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，用 ls -a 命令查看即可：12$ ls -a. .. .git 克隆现有的版本库如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 git clone 命令。 如果你对其它的 VCS 系统（比如说 Subversion ）很熟悉，请留心一下你所使用的命令是 clone 而不是 checkout。 这是 Git 区别于其它版本控制系统的一个重要特性，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库(虽然可能会丢失某些服务器端的挂钩设置，但是所有版本的数据仍在)。 克隆仓库的命令格式：1git clone &lt;repo&gt; 例如：1git clone https://github.com/ChengjinLi/machine_learning.git 如果我们需要克隆到指定的目录，可以使用以下命令格式：1git clone &lt;repo&gt; &lt;directory&gt; 例如：1git clone https://github.com/ChengjinLi/machine_learning.git mj_machine_learning 参数说明： repo：Git 仓库。 directory：本地目录。 Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议。 Git 文件生命周期请记住，「工作目录」下的每一个文件都不外乎这两种状态：「已跟踪」或「未跟踪」。「已跟踪」的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于「未修改」，「已修改」或「已放入暂存区」。 「工作目录」中除「已跟踪」文件以外的所有其它文件都属于「未跟踪」文件，它们既不存在于上次快照的记录中，也没有放入「暂存区」。 初次克隆某个仓库的时候，「工作目录」中的所有文件都属于「已跟踪」文件，并处于「未修改」状态。编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为「已修改」文件。 我们逐步将这些修改过的文件放入「暂存区」，然后提交所有暂存了的修改，如此反复。使用 Git 时文件的生命周期如下： Git 常用命令git add &lt;file_name&gt;/&lt;dir_name&gt;将文件添加到暂存区，参数可以是指定路径的文件名或目录的名字，也可以使用 glob 模式。 git status查看项目的当前状态，输出详细内容git status --short 或 git status -s查看项目的当前状态，以简短的结果输出状态说明： ?? 未跟踪的文件 M：修改过的文件，出现在靠左边的M表示该文件被修改了并放入了暂存区，出现在右边的M表示该文件被修改了但是还没放入暂存区， A：新添加到暂存区的文件 D：已删除(deleted) R：重命名(renamed) C：已拷贝(copied) U：已更新但为合并(updated but unmerged) git diff查看尚未 add 的所有文件的改动和上个已经 commit的文件的不同git diff &lt;file_name&gt;查看尚未 add 的 &lt;file_name&gt; 文件的改动和上个已经 commit的文件的不同git diff --cached查看已经 add 的文件的改动git diff HEAD查看已 add 的与未 add 的所有改动git diff --stat显示摘要而非整个diff git commit -m &quot;message&quot;将暂存区的文件提交到版本库，-m后面输入的是本次提交的说明，可以输入任意内容，最好是有意义的，方便从历史记录找到改动记录。git commit --amend --no-edit将本次改动直接合并到上一个 commit 中git commit -am &quot;message&quot;跳过使用暂存区的方式，自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。 git rm &lt;file_name&gt;/&lt;dir_name&gt;将文件从暂存区域移除，参数可以是指定路径的文件名或目录的名字，也可以使用 glob 模式。git rm --cached &lt;file_name&gt;/&lt;dir_name&gt;将文件从 Git 仓库中删除，但仍然希望保留在当前工作目录中，参数可以是指定路径的文件名或目录的名字，也可以使用 glob 模式。 git mv &lt;file_from&gt; &lt;file_to&gt;将 Git 中的 &lt;file_from&gt; 重命名为 &lt;file_to&gt; git log查看历史提交记录，显示从最近到最远的提交日志git log --oneline一行显示一次提交git log --oneline --graph查看历史中什么时候出现了分支、合并，开启了拓扑图选项git log --author=&lt;user_name&gt;查找指定用户 &lt;user_name&gt; 的提交日志 git reflog查看历史命令记录，显示从最近到最远的日志 git reset HEAD取消已缓存的内容，即取消之前 git add 添加的内容在 Git 中，用 HEAD 表示当前版本，上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成 HEAD~100。git reset &lt;file_name&gt;取消已缓存的&lt;file_name&gt;，即取消之前 git add 添加的内容git reset --hard &lt;commit_id&gt;回退到指定 &lt;commit_id&gt; 版本，&lt;commit_id&gt;没必要写全，前位(例如前7位)就可以了，Git 会自动去找，当然也不能只写前一两位，因为 Git 可能会找到多个版本号，就无法确定是哪一个了。 git checkout &lt;commid_id&gt; -- &lt;file_name&gt;将 &lt;file_name&gt; 回退到 &lt;commid_id&gt; 的版本git checkout &lt;branch_name&gt;将 HEAD 从当前分支切换到 &lt;branch_name&gt; 分支git checkout -b &lt;branch_name&gt;创建 &lt;branch_name&gt; 分支，并切换到新建的分支 git branch查看当前分支，*代表了当前 HEAD 所在的分支git branch &lt;branch_name&gt;创建 &lt;branch_name&gt; 分支 git merge &lt;branch_name&gt;将 &lt;branch_name&gt; 合并到当前分支，Git 会采用默认的 Fast forward 格式进行合并，这次合并操作不会有 commit 信息，log 中也不会有分支的图案。git merge --no-diff -m &quot;message&quot; &lt;branch_name&gt;采取 --no-ff 这种方式保留合并的 commit 信息。 忽略文件一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为.gitignore 的文件，列出要忽略的文件模式。要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。文件 .gitignore 的格式规范如下： 所有空行或者以 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号*匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号?只匹配一个任意字符；如果在方括号中使用短划线-分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有0到9的数字）。 使用两个星号*表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在 https://github.com/github/gitignore 找到它. Github 使用Github 是一个大家都积极贡献的地方， 你可以和各种人合作创作，也是开源的天堂， 只要你愿意, 任何人都能下载, 或修改你的杰作。在Github 上注册一个账户然后添加一个 online 版本库 repository连接本地版本库1git remote add [alias] [url] 例如：12$ git remote add origin https://github.com/ChengjinLi/machine_learning.git$ git push -u origin master # 推送本地 master 去 origin 在执行 commit 之后，可以执行 git push -u origin master 将本地修改提交到 Github 要查看当前配置有哪些远程仓库，可以用命令：12$ git remoteorigin 执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。123$ git remote -vorigin https://github.com/ChengjinLi/machine_learning.git (fetch)origin https://github.com/ChengjinLi/machine_learning.git (push) 删除别名为 &lt;alias&gt; 的远程仓库1$ git remote rm &lt;alias&gt; 相关链接Git 官网： https://git-scm.com/Git 完整命令手册地址： http://git-scm.com/docsPro Git book： https://git-scm.com/book/zh/v2廖雪峰Git教程：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000菜鸟Git教程： http://www.runoob.com/git/git-tutorial.htmlGithub 官网： https://github.com/]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim常用命令教程]]></title>
    <url>%2F2017%2F08%2F04%2Fvim-command-tutorial%2F</url>
    <content type="text"><![CDATA[vim 的配置文件在根目录的 .vimrc 文件中，如果没有，自己创建一个。打开 .vimrc 文件，输入配置，配置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051set paste &quot; 进入paste模型set number &quot; 显示行号set tabstop=4 &quot; 一个tab为4个空格长度set shiftwidth=4 &quot; 将换行自动缩进设置成4个空格set expandtab &quot; 输入tab时自动将其转化为空格set sts=4 &quot; 敲入tab键时实际占有的列数set autoindent &quot; 设置自动缩进set smartindent &quot; 智能缩进set mouse=a &quot; 鼠标可用syntax on &quot; 语法高亮set hlsearch &quot; 开启查找匹配的高亮显示, 简写set hls&quot; set nohlsearch &quot; 关闭查找匹配的高亮显示, 简写set nohlsset encoding=utf-8 &quot; 屏幕显示的编码set fileencoding=utf-8 &quot; 正在被编辑的文件的编码set fileencodings=ucs-bom,utf-8,cp936,gbk,gb2312set termencoding=utf-8set showmatch &quot; 括号匹配 set ruler &quot; 右下角显示光标状态行 set incsearch &quot; 设置快速搜索 set foldenable &quot; 开启代码折叠 set fdm=manual &quot; 手动折叠 set foldmethod=syntax &quot; 自动语法折叠 set modeline &quot; 自动载入模式行set cursorline &quot; 开启光亮光标行set cursorcolumn &quot; 开启光亮光标列&quot; vundle 环境设置filetype offset rtp+=~/.vim/bundle/Vundle.vim vundle 管理的插件列表必须位于 vundle#begin() 和 vundle#end() 之间call vundle#begin()Plugin &apos;altercation/vim-colors-solarized&apos;Plugin &apos;tomasr/molokai&apos;Plugin &apos;vim-scripts/phd&apos;Plugin &apos;Lokaltog/vim-powerline&apos;Plugin &apos;octol/vim-cpp-enhanced-highlight&apos;Plugin &apos;Raimondi/delimitMate&apos;Plugin &apos;scrooloose/nerdtree&apos;Plugin &apos;vim-scripts/indentpython.vim&apos;Plugin &apos;davidhalter/jedi-vim&apos;&quot;Plugin &apos;w0rp/ale&apos;Plugin &apos;Shougo/neocomplete.vim&apos;Plugin &apos;majutsushi/tagbar&apos;&quot; 插件列表结束call vundle#end()filetype plugin indent onmap &lt;F3&gt; :nohlsearch&lt;CR&gt; &quot; 绑定快捷键来去掉当前显示的高亮（一次性）:set pastetoggle=&lt;F10&gt; &quot; 绑定快捷键来激活/取消 paste模式nnoremap &lt;silent&gt; &lt;F11&gt; :AV&lt;CR&gt; map &lt;F12&gt; :q&lt;CR&gt; &quot; 绑定快捷键来退出当前vim编辑： 设置说明： set shiftwidth(简写：sw) 这个是用于程序中自动缩进所使用的空白长度。一般来说为了保持程序的美观，和下面的参数最好一致。同时它也是符号移位长度的制定者。 set tabstop(简写：ts) 定义tab所等同的空格长度，linux 内核代码建议每个tab占用8列，因为如果是其它值的话，可能引起文件在打印之类的场合中看起来很别扭。 set expandtab(简写：et) 输入tab时自动将其转化为空格，这样的话就不会一起混淆，不过毕竟制表符为8是最常用最普遍的设置，所以一般还是不要改。举个例子，在多人一起开发项目时，为了使代码风格尽量保持一致，一般不允许在代码使用TAB符，而以4个空格代之。 set softtabstop(简写：sts) 敲入tab键时实际占有的列数。如果我们希望改变程序中的缩进怎么办？shiftwidth和tabstop不一样的话，你会发现程序比较难看的。这时候，softtabstop就起作用了。可以从vim的说明中看到，一旦设置了softtabstop的值时，你按下tab键，插入的是空格和tab制表符的混合，具体如何混合取决于你设定的softtabstop，举个例子，如果设定softtabstop=8, 那么按下tab键，插入的就是正常的一个制表符;如果设定 softtabstop=16,那么插入的就是两个制表符；如果softtabstop=12,那么插入的就是一个制表符加上4个空格；如果softtabstop=4呢？那么一开始，插入的就是4个空格，此时一旦你再按下一次tab，这次的四个空格就会和上次的四个空格组合起来变成一个制表符。换句话说，softtabstop是“逢8空格进1制表符”,前提是你tabstop=8。 set number(简写：nu) 显示行号 set nonumber(简写：nonu) 关闭行号显示 set ruler 设置在窗口右下角显示行号，与上面的好处是，节省空间 set autoindent(简写：ai) 设置自动缩进 syntax on 语法高亮 set smartindent 智能缩进 set encoding 屏幕显示的编码，目前大部分Linux系统已经将utf-8作为默认locale，encoding就应是utf-8以方便显示。该选项使用于缓冲的文本(你正在编辑的文件)，寄存器，Vim 脚本文件等等。你可以把 ‘encoding’ 选项当作是对 Vim 内部运行机制的设定。 set fileencoding 正在被编辑的文件的编码，它也决定新文件的编码。如果为空，表示与encoding相同。如果与encoding不同，vi将会在保存和读取时做二者之间的转换。 set fileencodings 供vim尝试的编码列表，vi会逐个尝试每一项，如果没有发生错误，就设置当前的fileencoding为与该项相同的值。如果均失败，fileencoding将为空。 set termencoding 输出到客户终端（Term）采用的编码类型，默认空值，也就是输出到终端不进行编码转换。 set showmatch 括号匹配 set ruler 右下角显示光标状态行 set incsearch 设置快速搜索 set foldenable 开启代码折叠 set fdm=manual 手动折叠 set foldmethod=syntax 自动语法折叠 set modeline 自动载入模式行 set ignorecase 大小写无关 set noignorecase 大小写敏感 set hlsearch 开启查找匹配的高亮显示, 简写set hls set nohlsearch 关闭查找匹配的高亮显示, 简写set nohls :nohlsearch 去掉当前显示的高亮（一次性） :set paste 进入paste模型,进入 paste 模式后，按 i 键进入插入模式，然后再粘帖，文本格式不会错乱了。但粘帖后还需要按 进入普通模式并执行如下命令结束 paste 模式： :set nopaste 结束 paste 模式 :set pastetoggle= paste有一个切换paste开关的选项，这就是pastetoggle。通过它可以绑定快捷键来激活/取消 paste模式 vim 的插件使用 vundle 管理： 安装 vundle：1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 安装插件，先找到其在 github.com 的地址，再将配置信息加入 .vimrc 中的call vundle#begin() 和 call vundle#end() 之间，如我的配置文件所示，Plugin ‘插件地址’ 即为添加插件，例如:1Plugin &apos;majutsushi/tagbar&apos; 最后进入 vim 执行：1:PluginInstall 便安装完成插件。 如需删除插件，只需将 Plugin ‘插件地址’ 删除或者注释掉，再进入 vim 执行： 1:PluginClean 便将插件删除。 如需升级插件，进入 vim 执行：1:PluginUpdate 便完成升级。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地挂载服务器文件夹工具---「sshfs」的安装及使用]]></title>
    <url>%2F2017%2F08%2F03%2Fsshfs-install-and-using-on-mac%2F</url>
    <content type="text"><![CDATA[对于习惯在本地使用「IDE」工具进行编辑而不习惯在服务器上使用 「vim」 进行编辑的同学，下面介绍一个非常方便的在本地挂载服务器文件夹的工具 「sshfs」。下面介绍在「Mac」(系统版本：macOS Sierra 10.12.6)下的安装及使用方法： 安装「sshfs」安装 Homebrew 先确定是否已经安装「Homebrew」，在命令行执行如下命令：1brew -v 输出示例：12Homebrew &gt;1.2.0 (no git repository)Homebrew/homebrew-core (git revision 9cf7; last commit 2017-09-22) 如果没有安装，则执行如下命令进行安装，在命令行执行如下命令：1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装 「sshfs」 的依赖 「osxfuse」执行如下命令：1brew install caskroom/cask/osxfuse 安装 「sshfs」执行如下命令：1brew install sshfs 使用 「sshfs」 挂载执行如下命令：1sshfs -C -o reconnect user@hostname:remote_dir local_dir 参数说明如下： user: 远程连接用户名 hostname: 远程连接的主机名 remote_dir: 远程目录 local_dir: 本地目录 查看挂载情况1df -h local_dir 使用 「umount」 取消挂载1umount local_dir 相关问题如过我们的Mac休眠或重启, 发现挂载的失败了, 进入目录：1ls local_dir 会提示如下类似信息：1ls: local_dir: Input/output error 取消挂载1umount local_dir 又会提示1umount: local_dir: not currently mounted 这个时候, 我们不得不关闭进程了, 可以先通过命令查看进程1pgrep -lf sshfs 然后杀掉相应的挂载进程, 或者直接杀掉所有挂载进程1pkill -9 sshfs 之后重新挂载响应的目录即可 相关链接：http://www.jianshu.com/p/8723ba79f35a]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>sshfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 使用教程]]></title>
    <url>%2F2017%2F08%2F02%2Fmarkdown-using-tutorial%2F</url>
    <content type="text"><![CDATA[标题语法：1不同数量的# 标题内容 说明：在Markdown中，标题共计六个等级，标题字号随等级的升高而相应的降低。 示例： 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 示例显示效果： 一级标题二级标题三级标题四级标题五级标题六级标题 斜体、粗体、加粗斜体、删除线语法：1234*斜体***粗体*****加粗斜体***~~删除线~~ 示例显示效果： 斜体粗体加粗斜体删除线 链接自动链接语法：1&lt;链接地址&gt; 说明：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，Markdown 就会自动把它转成链接。示例：1&lt;https://chengjinli.github.io/&gt; 示例显示效果： https://chengjinli.github.io/ 超链接语法：1[链接文字](链接地址 &quot;链接标题&quot;) 说明：()中的””之间可以为链接指定title，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title 文字。链接地址与链接标题前有一个空格。示例：1[MJ&apos;s Learning Notes](https://chengjinli.github.io/) 示例显示效果： MJ’s Learning Notes 列表有序列表语法：1数字加一个英文句点 示例：121. 有序列表12. 有序列表2 示例显示效果： 有序列表1 有序列表2 无序列表语法：1*，+，- 加上列表内容 示例：123456* 无序列表1* 无序列表2+ 无序列表3+ 无序列表4- 无序列表5- 无序列表6 示例显示效果： 无序列表1 无序列表2 无序列表3 无序列表4 无序列表5 无序列表6 引用单层引用语法：1&gt;加上被引用的内容 示例：1&gt; 一行内容的引用 示例显示效果： 一行内容的引用 多层引用语法：1不同数量的&gt;加上被引用的内容 示例：12345&gt;&gt;&gt;第3层引用&gt;&gt;第2层引用&gt;第1层引用 示例显示效果： 第3层引用 第2层引用 第1层引用 引用其他元素语法：1引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 示例：123456&gt; ### 三级标题&gt; 1. 第一行列表内容&gt; 2. 第二行列表内容&gt; &gt; 插入代码的例子&gt; `print (&quot;MJ&quot;)` 示例显示效果： 三级标题 第一行列表内容 第二行列表内容 print (&quot;MJ&quot;) 插入图片语法：1![图片Alt](图片地址 &quot;图片Title&quot;) 说明：[]中写图片Alt，如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。()里写图片地址，()图片Title表示鼠标悬停在图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。示例：1![头像](https://chengjinli.github.io/images/MJ.jpg &quot;MJ&quot;) 示例显示效果： LaTeX公式行内公式语法：1$公式$ 示例：1质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 示例显示效果： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 正行公式1$$公式$$ 示例：123$$\sum_&#123;i=1&#125;^n a_i=0$$$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$$$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$$ 示例显示效果： $$\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2$$ 表格语法说明： 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符“|”隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐，在 “-” 右边加上 “:” 为右对齐，在 “-” 两侧同时加上 “:” 为居中对齐。 示例：12345|年|月|日||-|:-:|-:||2015|5|5||2016|6|6||2017|7|7| 示例显示效果： 年 月 日 2015 5 5 2016 6 6 2017 7 7 分割线语法：你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：示例:1234* * *********- - - 示例显示效果： 代码行内代码语法：1`代码` 示例：1python语言里的函数`print()`怎么使用？ 示例显示效果： python语言里的函数print()怎么使用？ 多行代码语法：```第1行代码第2行代码``` 示例：```pythonif name == ‘main‘: print(“MJ”)``` 示例显示效果：12if __name__ == '__main__': print("MJ") 缩进式代码语法：缩进 4 个空格或是 1 个制表符，一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 示例：12if __name__ == '__main__': print("MJ") 示例显示效果: if __name__ == &apos;__main__&apos;: print(&quot;MJ&quot;) 相关链接：http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-6]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo + Next + github/coding 搭建个人静态博客]]></title>
    <url>%2F2017%2F08%2F01%2Fuse-hexo-next-github-and-coding-build-static-blog%2F</url>
    <content type="text"><![CDATA[博客框架使用 Hexo主题使用 NexT代码托管使用 Coding Next主题修改文章内链接文本样式实现效果：https://chengjin.li/ 在themes\next\source\css\_common\components\post\post.styl文件如下位置添加css样式：123456789101112131415.post-sticky-flag &#123; display: inline-block; font-size: 16px; -ms-transform: rotate(30deg); transform: rotate(30deg);&#125;// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #fc6423; border-bottom: none; &#125;&#125; Next主题添加鼠标心形点击特效1、 在themes\next\source\js\src\目录下新建love.js,代码如下:1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 2、 在themes\next\layout\_layout.swig文件的最下方，&lt;/body&gt;前面添加如下代码：1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; Next主题修改文章底部的那个带#号的标签实现效果： 方法：修改模板themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; Next主题在每篇文章末尾统一添加“本文结束”标记实现效果：方法： 在路径themes\next\layout\_macro 中新建 passage-end-tag.swig 文件，并添加以下内容：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开themes\next\layout\_macro\post.swig文件，在 post-body 之后， post-footer 之前添加如下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件_config.yml，在末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true Next主题修改作者头像并旋转打开themes\next\source\css\_common\components\sidebar\sidebar-author.styl，修改site-author-image相代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 70px; -webkit-border-radius: 70px; -moz-border-radius: 70px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; Next主题设置网站的图标Favicon方法：将一张32x32的ico图标名称改为favicon.ico，然后把图标放在themes/next/source/images里，并且修改主题配置文件：12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /images/favicon.ico]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
