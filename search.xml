<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[词向量简介]]></title>
      <url>/2017/11/01/word-vector-abstract/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>自然语言是一套用来表达含义的复杂系统。在这套系统中，词是表义的基本单元。在 <strong><code>NLP</code></strong> 领域中，如何量化词的表达也是关键问题之一。用某个固定维度的向量(<strong><code>vector</code></strong>)去表示词是一个很经典很基本的任务，我们称这个向量为「词向量」，通常也被认为是词的特征向量。我们之所以要把单词变成向量是因为我们需要把自然语言抽象成数学中的某个概念（这里是向量）。换一种更具体直白的说法，之所以要把单词变成固定维度的向量，是因为绝大多数的机器学习(<strong><code>Machine Learning</code></strong>)模型需要固定维度的向量作为输入。近年来，「词向量」已逐渐成为自然语言处理的基础知识，一份高质量的「词向量」是很多任务取得更好表现的关键。常见的方式有以下两种：</p>
<blockquote>
<ol>
<li>独热编码(One-Hot Encoding)</li>
<li>词嵌入(Word Embedding)<a id="more"></a>
</li>
</ol>
</blockquote>
<h1 id="独热编码-One-Hot-Encoding"><a href="#独热编码-One-Hot-Encoding" class="headerlink" title="独热编码(One-Hot Encoding)"></a>独热编码(One-Hot Encoding)</h1><p>独热编码即 <strong><code>One-Hot</code></strong> 编码，又称一位有效编码，直观来说就是使用 <strong><em><code>N</code></em></strong> 位状态寄存器对 <strong><em><code>N</code></em></strong> 个状态进行编码，每个状态都有其独立的寄存器位，并且在任意时候有且只有一位有效，即只有一个值为 <strong><code>1</code></strong>，其他值全为 <strong><code>0</code></strong> 的一种码制。在机器学习的任务中，对于离散型的分类型的数据，需要对其进行数字化，比如说「性别」这一属性，只能有「男性」、「女性」或者「其他」这三种值，如何对这三个值进行数字化表达呢？一种简单的方式就是「男性」为 <strong><code>0</code></strong>，「女性」为 <strong><code>1</code></strong>，「其他」为 <strong><code>2</code></strong>。使用上面简单的方式对分类值进行数字化后，进行模型训练时可能会产生一个问题：特征因为数字值的不同影响模型的训练效果，在模型训练的过程中不同的值使得同一特征在样本中的权重可能发生变化。假如直接编码成 <strong><code>100</code></strong>，是不是比编码成 <strong><code>1</code></strong> 对模型的的影响更大？为了解决上述的问题，使训练过程中不受到因为分类值数字化的问题对模型产生的负面影响，引入独热码对分类型的特征进行独热码编码。</p>
<p>在 <strong><code>NLP</code></strong> 任务中，假设词典中不同词的数量为 <strong><em><code>N</code></em></strong>，每个词的 <strong><code>index</code></strong> 都与 <strong><code>0</code></strong> 到 <strong><em><code>N-1</code></em></strong> 的连续整数一一对应。假设一个词的下标为 <strong><em><code>i</code></em></strong>，为了得到该词的 <strong><code>One-Hot</code></strong> 向量表示，我们创建一个全 <strong><code>0</code></strong> 的长为 <strong><em><code>N</code></em></strong>的向量，并将其第 <strong><em><code>i</code></em></strong>位置成 <strong><code>1</code></strong>。<strong><code>One-Hot</code></strong> 编码使用了高维稀疏向量表示词，这样的特征可以反映词出现的频率，但这并不是最好的选择。一个主要的原因是，<strong><code>One-Hot</code></strong> 词向量无法表达不同词之间的关系，例如「相似度」这一度量关系。任何一对词的 <strong><code>One-Hot</code></strong> 向量的余弦相似度都为 <strong><code>0</code></strong>。</p>
<p>那究竟用什么向量去表示词才是合理的呢？一个符合直觉的想法是，相似的词应该有相似的「词向量」，比如 <strong><code>dog</code></strong> 和 <strong><code>cat</code></strong> 这两个词，他们的意思很相近，那么他们的「词向量」也应该很相似，或者说他们的「词向量」在空间中位置很接近，距离很短。再比如 <strong><code>dog</code></strong> 和 <strong><code>rocket</code></strong> 这两个词，他们的「词向量」在空间中位置应该距离比较远。我们应该怎样做才能使得相似的词有相似的「词向量」呢？</p>
<h1 id="词嵌入-Word-Embedding"><a href="#词嵌入-Word-Embedding" class="headerlink" title="词嵌入(Word Embedding)"></a>词嵌入(Word Embedding)</h1><p>目前大多数人所述的「词向量」，其实指的就是「词嵌入」。与 <strong><code>One-Hot</code></strong> 编码相比而言，「词嵌入」技术将词汇的上下文关系嵌入到一个低维空间。举一个简单的例子，在字典用我们会用几千个常用词去解释每个词的意思，而「词向量」中，我们用(比如) <strong><code>100</code></strong> 维的实数向量去表示字典中的词。换一种说法，我们要把字典中每一个词映射到某个维度(比如 <strong><code>100</code></strong> 维)的空间当中去，所以我们也可以把「词向量」叫做「空间向量模型」(<strong><code>Vector Space Model</code></strong>)。「词嵌入」模型几乎都利用了语言学中这样的一个规律：相似的词有着相似的上下文。这个规律叫 <strong><code>Distributional Hypothesis</code></strong>。原理基本都是词的上下文的分布可以揭示这个词的语义，就好比“看看你跟什么样的人交往，就知道你是什么样的人”，所以「词向量」模型的核心就是对上下文的关系进行建模。还是以 <strong><code>dog</code></strong> 和 <strong><code>cat</code></strong> 两个词为例，他们是比较相似的单词，他们在语料中的上下文也很相近。他们的上下文中一般都会出现关于动物、宠物的单词或短语。所以，目前主流的「词向量」模型表面上千差万别，但是本质都很相似，都是对词与其上下文的关系进行建模，从而得到高质量的「词向量」。目前比较有代表性的工具有 <strong><code>word2vec</code></strong>、<strong><code>GloVe</code></strong> 和 <strong><code>fastText</code></strong> 等。</p>
<h1 id="词类比-Word-Analogy"><a href="#词类比-Word-Analogy" class="headerlink" title="词类比(Word Analogy)"></a>词类比(Word Analogy)</h1><p>上面已经提到，「词向量」会把相似的词映射到空间中相近的位置中去。所以我们可以用「词向量」找到和某个词相近的词。除此之外，「词向量」还有另一个比较优美的性质，「词类比」(<strong><code>Word Analogy</code></strong>)。在词类比任务中，我们需要通过前三个单词，例如 <strong><code>Athens</code></strong>、<strong><code>Greece</code></strong>、<strong><code>Baghdad</code></strong>，推导出第四个单词 <strong><code>Iraq</code></strong>。推导的过程就是「雅典」和「希腊」是首都的关系，「巴格达」和谁是首都的关系？答案是「伊拉克」。要做好这个任务，就要求我们还需要从「词向量」中得到词之间关系的信息，比如在上述例子中，这个关系就是「首都」。当年 <strong><code>word2vec</code></strong> 出现以后受到大家广泛关注，一个可能的原因就是大家惊讶于「词向量」能在 <strong><code>Word Analogy</code></strong>数据集上取得这么好的效果，原来「词向量」还有这样神奇的性质。</p>
<p>那「词向量」为何有能力做好 <strong><code>Word Analogy</code></strong> 这个任务呢？在 <strong><code>word2vec</code></strong> 中用 <strong><code>vec(&#39;wife&#39;) + vec(&#39;king&#39;) - vec(&#39;queen&#39;)</code></strong> 去寻找 <strong><code>husband</code></strong> 这个词，这种加加减减的操作看似没有什么道理，这里先给一个例子帮助大家直观的理解。我们以 <strong><code>king</code></strong>、<strong><code>queen</code></strong> 这两个词为例。假设语料中 <strong><code>king</code></strong> 周围出现的词主要和「皇室」这个主题以及「男性」这个主题有关。<strong><code>queen</code></strong> 周围出现的词主要和「皇室」这个主题和「女性」这个主题有关。我们令 <strong><code>vec(&#39;皇室&#39;)</code></strong>为所有有关「皇室」主题的词的「词向量」的平均，<strong><code>vec(&#39;男性&#39;)</code></strong> 和 <strong><code>vec(&#39;女性&#39;)</code></strong> 分别为所有有关「男性」和「女性」主题的词的「词向量」的平均。我们在上面内容中提到过，词的语义能通过它在语料中的上下文中的信息体现出来。我们这里就认为 <strong><code>vec(&#39;king&#39;) = 1/2(vec(&#39;皇室&#39;) + vec(&#39;男性&#39;))</code></strong>，<strong><code>vec(&#39;queen&#39;) = 1/2(vec(&#39;皇室&#39;) + vec(&#39;女性&#39;))</code></strong>。所以 <strong><code>vec(&#39;king&#39;) - vec(&#39;queen&#39;)</code></strong> 就等于 <strong><code>1/2(vec(&#39;男性&#39;)-vec(&#39;女性&#39;))</code></strong>。同理，对于 <strong><code>husband</code></strong>、<strong><code>wife</code></strong> 这两个词，<strong><code>husband</code></strong> 周围的词是关于「伴侣」和「男性」的主题，<strong><code>wife</code></strong> 周围的词是关于<br>「伴侣」和「女性」的主题。<strong><code>vec(&#39;husband&#39;) - vec(&#39;wife&#39;)</code></strong> 同样等于<strong><code>1/2(vec(&#39;男性&#39;)- vec(&#39;女性&#39;))</code></strong> 。这样 <strong><code>vec(&#39;husband&#39;) - vec(&#39;wife&#39;)</code></strong> 就等于<strong><code>vec(&#39;king&#39;) - vec(&#39;queen&#39;)</code></strong> ，我们就能轻易的通过三个词，去推断出第四个词。而 <strong><code>vec(&#39;king&#39;) - vec(&#39;queen&#39;)</code></strong> 也很好的反映了「男性」与「女性」这样一个关系。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在之后的「词向量」系列博文中，我会全面细致的解析包括 <strong><code>word2vec</code></strong>、<strong><code>GloVe</code></strong> 和 <strong><code>fastText</code></strong> 等一系列「词向量」工具包。通过上面提到的工具包，我们可以得到高质量的「词向量」，也可以根据我们的需求，得到不同性质的「词向量」</p>
]]></content>
      
        <categories>
            
            <category> 词向量 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 词向量 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++学习笔记---map容器使用教程]]></title>
      <url>/2017/10/27/cpp-container-map-use-tutorial/</url>
      <content type="html"><![CDATA[<p>注意事项:</p>
<ol>
<li>在<strong><code>map</code></strong>中，由<strong><code>key</code></strong>查找<strong><code>value</code></strong>时，首先要判断<strong><code>map</code></strong>中是否包含<strong><code>key</code></strong>。</li>
<li>如果不检查，直接返回<strong><code>map[key]</code></strong>，可能会出现意想不到的行为。如果<strong><code>map</code></strong>包含<strong><code>key</code></strong>，没有问题，如果<strong><code>map</code></strong>不包含<strong><code>key</code></strong>，使用下标有一个危险的副作用，会在<strong><code>map</code></strong>中插入一个<strong><code>key</code></strong>的元素，<strong><code>value</code></strong>取默认值，返回<strong><code>value</code></strong>。也就是说，<strong><code>map[key]</code></strong>不可能返回<strong><code>null</code></strong>。</li>
<li><strong><code>map</code></strong>提供了两种方式，查看是否包含<strong><code>key</code></strong>，<strong><code>map.count(key)</code></strong>、<strong><code>map.find(key)</code></strong>。</li>
<li><strong><code>map.count(key)</code></strong>：由于<strong><code>map</code></strong>不包含重复的<strong><code>key</code></strong>，因此<strong><code>map.count(key)</code></strong>取值为<strong><code>0</code></strong>，表示不包含，取值为<strong><code>1</code></strong>，表示包含。</li>
<li><strong><code>map.find(key)</code></strong>：返回迭代器，判断是否存在。</li>
<li>对于<strong><code>STL</code></strong>中的容器，有泛型算法<strong><code>find(begin，end，target)</code></strong>查找目标，<strong><code>map</code></strong>还提供了一个成员方法<strong><code>find(key)</code></strong>。</li>
<li>对于下面的场景，存在<strong><code>key</code></strong>就使用，否则返回<strong><code>null</code></strong>，有下面两种写法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="number">1</span> == <span class="built_in">map</span>.count(key)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">map</span>[key];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> null;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iter = <span class="built_in">map</span>.find(key);</div><div class="line"><span class="keyword">if</span>(iter != <span class="built_in">map</span>.end()) &#123;</div><div class="line">    <span class="keyword">return</span> iter-&gt;second;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> null;</div></pre></td></tr></table></figure>
<p>这里需要注意：前一种方法很直观，但是效率差很多。因为前面的方法，需要执行两次查找。因此，推荐使用后一种方法。</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++,container </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++学习笔记---vector容器使用教程]]></title>
      <url>/2017/10/21/cpp-container-vector-use-tutorial/</url>
      <content type="html"><![CDATA[<h1 id="利用-remove-if-和-erase-从-vector-中移除指定-set-中包含的元素"><a href="#利用-remove-if-和-erase-从-vector-中移除指定-set-中包含的元素" class="headerlink" title="利用 remove_if() 和 erase() 从 vector 中移除指定 set 中包含的元素"></a>利用 <code>remove_if()</code> 和 <code>erase()</code> 从 <code>vector</code> 中移除指定 <code>set</code> 中包含的元素</h1><a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; replace_str_set&#123;<span class="string">","</span>, <span class="string">"."</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsReplaceStr</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (replace_str_set.find(str) != replace_str_set.end()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; string_vector&#123;<span class="string">"a"</span>, <span class="string">","</span>, <span class="string">"b"</span>, <span class="string">"."</span>, <span class="string">"c"</span>&#125;;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator it;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"before replace: "</span>;</div><div class="line">    <span class="keyword">for</span> (it = string_vector.begin(); it != string_vector.end(); it++) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it; &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    string_vector.erase(remove_if(string_vector.begin(), string_vector.end(), IsReplaceStr), string_vector.end());</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after replace: "</span>;</div><div class="line">    <span class="keyword">for</span> (it = string_vector.begin(); it != string_vector.end(); it++) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">before replace: a,b.c</div><div class="line">after replace: abc</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++,container </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++学习笔记---容器(container)使用教程]]></title>
      <url>/2017/10/20/cpp-container-use-tutorial/</url>
      <content type="html"><![CDATA[<p>在 <strong><code>C++</code></strong> 的 <strong><code>STL</code></strong> 中，常见的容器可分为<strong>「顺序容器」(sequential container)</strong> 和<strong>「关联容器」(associative container)</strong>。<br><a id="more"></a></p>
<p>标准的 <strong><code>STL</code> 「顺序容器」</strong>包括：</p>
<p><strong><code>vector</code></strong>、<strong><code>deque</code></strong>、<strong><code>list</code></strong>、<strong><code>forward_list</code></strong>、<strong><code>array</code></strong> 与 <strong><code>string</code></strong>。</p>
<p>标准的 <strong><code>STL</code>「关联容器」</strong>可分为<strong>「关键字有序」</strong>和<strong>「关键字无序」</strong>。</p>
<p>关键字有序：<strong><code>map</code></strong>、<strong><code>set</code></strong>、<strong><code>multimap</code></strong>和<strong><code>multiset</code></strong>。</p>
<p>关键字无序： <strong><code>unorder_map</code></strong>、<strong><code>unorder_set</code></strong>、<strong><code>unorder_multimap</code></strong>和<strong><code>unorder_multiset</code></strong>。</p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a><strong><code>vector</code></strong></h3><p><strong><code>vector</code></strong>将元素保存在连续的内存空间中，支持随机存取。由于元素是连续存储的，在这两种容器中间插入和删除元素，需要修改该位置之后所有元素的位置，效率较低。如果不清楚元素的确切个数，请使用<strong><code>vector</code></strong>，如果清楚元素的确切个数，请使用数组。</p>
<h3 id="string、"><a href="#string、" class="headerlink" title="string、"></a><strong><code>string</code></strong>、</h3><p><strong><code>string</code></strong>将元素保存在连续的内存空间中，支持随机存取。由于元素是连续存储的，在这两种容器中间插入和删除元素，需要修改该位置之后所有元素的位置，效率较低。</p>
<h3 id="list、forward-list"><a href="#list、forward-list" class="headerlink" title="list、forward_list"></a><strong><code>list</code></strong>、<strong><code>forward_list</code></strong></h3><p><strong><code>list</code></strong>和<strong><code>forward_list</code></strong>分别对应数据结构中的双向链表和单向链表。两个容器将元素的设计目的是让容器在任何位置的插入和删除效率提高，但其代价是容器不支持随机存取，查找效率较低。</p>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a><strong><code>deque</code></strong></h3><p><strong><code>deque</code></strong>是一种更为复杂的数据结构。与<strong><code>string</code></strong>和<strong><code>vector</code></strong>类似，支持快速随机访问，并且在其两端添加和删除元素的效率都很高。但是，由于<strong><code>deque</code></strong>中元素也是连续存储，在其中间插入和删除元素的效率也较低。</p>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a><strong><code>array</code></strong></h3><p><strong><code>array</code></strong>是一种更安全的数组，与内置数组类似，不支持动态内存分配，支持元素随机访问。</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++,container </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TensorFlow Tensor变换API]]></title>
      <url>/2017/10/19/tensorflow-tensor-transform-api/</url>
      <content type="html"><![CDATA[<h1 id="tf-stack"><a href="#tf-stack" class="headerlink" title="tf.stack()"></a>tf.stack()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">stack(</div><div class="line">    values, </div><div class="line">    axis=0, </div><div class="line">    name=&quot;stack&quot;</div><div class="line">)</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>官方文档：</p>
<blockquote>
<p><a href="https://www.tensorflow.org/api_docs/python/tf/stack" target="_blank" rel="external">https://www.tensorflow.org/api_docs/python/tf/stack</a></p>
</blockquote>
<p>定义：</p>
<blockquote>
<p><a href="https://github.com/tensorflow/tensorflow/blob/r1.3/tensorflow/python/ops/array_ops.py" target="_blank" rel="external">tensorflow/python/ops/array_ops.py</a></p>
</blockquote>
<p>功能：</p>
<blockquote>
<p>将由 <code>R</code> 维的 <code>tensor</code> 堆成 <code>R+1</code> 维的 <code>tensor</code> .</p>
</blockquote>
<p>说明：</p>
<blockquote>
<p>通过沿着 <code>axis</code> 维，将 <code>values</code> 中的 <code>tensor</code> 列表填充到一个比<code>values</code> 中的 <code>tensor</code> 高一维的 <code>tensor</code>中。</p>
<p>给定一个长度为 <code>N</code> ，由 <code>shape</code> 为 <code>（A，B，C）</code> 的 <code>tensor</code> 构成的列表；</p>
<p>如果 <code>axis == 0</code>，输出的  <code>tensor</code> 的 <code>shape</code> 为 <code>(N, A, B, C)</code></p>
<p>如果 <code>axis == 1</code>，输出的  <code>tensor</code> 的 <code>shape</code> 为 <code>(A, N, B, C)</code></p>
</blockquote>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line">x = [<span class="number">1</span>, <span class="number">4</span>]</div><div class="line">y = [<span class="number">2</span>, <span class="number">5</span>]</div><div class="line">z = [<span class="number">3</span>, <span class="number">6</span>]</div><div class="line"></div><div class="line">stack_0 = tf.stack([x, y, z])</div><div class="line"><span class="keyword">print</span> (stack_0.get_shape())     <span class="comment"># (3, 2)</span></div><div class="line">stack_1 = tf.stack([x, y, z], axis=<span class="number">1</span>)</div><div class="line"><span class="keyword">print</span> (stack_1.get_shape())     <span class="comment"># (2, 3)</span></div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    stack_0_val, stack_1_val = sess.run([stack_0, stack_1])</div><div class="line">    <span class="keyword">print</span> (<span class="string">'stack_0_val:'</span>)</div><div class="line">    <span class="keyword">print</span> (stack_0_val)     <span class="comment"># [[1, 4], [2, 5], [3, 6]]</span></div><div class="line">    <span class="keyword">print</span> (<span class="string">'stack_0_val.shape: %s'</span> % str(stack_0_val.shape))     <span class="comment"># (3, 2)</span></div><div class="line">    <span class="keyword">print</span> (<span class="string">'stack_1_val:'</span>)</div><div class="line">    <span class="keyword">print</span> (stack_1_val)     <span class="comment"># [[1, 2, 3], [4, 5, 6]]</span></div><div class="line">    <span class="keyword">print</span> (<span class="string">'stack_1_val.shape: %s'</span> % str(stack_1_val.shape))     <span class="comment"># (2, 3)</span></div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">stack_0.get_shape(): (3, 2)</div><div class="line">stack_1.get_shape(): (2, 3)</div><div class="line">stack_0_val:</div><div class="line">[[1 4]</div><div class="line"> [2 5]</div><div class="line"> [3 6]]</div><div class="line">stack_0_val.shape: (3, 2)</div><div class="line">stack_1_val:</div><div class="line">[[1 2 3]</div><div class="line"> [4 5 6]]</div><div class="line">stack_1_val.shape: (2, 3)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> TensorFlow </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TensorFlow的2种安装方法---pip安装和源码安装]]></title>
      <url>/2017/10/01/tensorflow-install/</url>
      <content type="html"><![CDATA[<p>本篇学习笔记是在 <strong><code>macOS</code></strong> 系统上进行的演示，<strong><code>python</code></strong> 版本为 <strong><code>2.7.10</code></strong>，如果大家想学习在 <strong><code>windows</code></strong>，<strong><code>linux</code></strong> 等系统上的安装步骤，可以参考一下官方的安装 <strong><code>TensorFlow</code></strong> 的方法：<a href="https://www.tensorflow.org/install/" target="_blank" rel="external">https://www.tensorflow.org/install/</a> ，个人建议在虚拟环境下安装 <strong><code>TensorFlow</code></strong>。下面介绍 <strong><code>TensorFlow</code></strong> 的2种安装方法。<br><a id="more"></a></p>
<h1 id="通过「pip」直接安装"><a href="#通过「pip」直接安装" class="headerlink" title="通过「pip」直接安装"></a>通过「pip」直接安装</h1><h2 id="安装「pip」"><a href="#安装「pip」" class="headerlink" title="安装「pip」"></a>安装「pip」</h2><p>如果已经安装，跳过此步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo easy_install pip</div></pre></td></tr></table></figure></p>
<p>查看 <strong><code>pip</code></strong> 是否安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip —version</div></pre></td></tr></table></figure></p>
<h2 id="安装「tensorflow」"><a href="#安装「tensorflow」" class="headerlink" title="安装「tensorflow」"></a>安装「tensorflow」</h2><p>安装CPU版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install tensorflow</div></pre></td></tr></table></figure></p>
<p>安装GPU版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install tensorflow-gpu</div></pre></td></tr></table></figure></p>
<p>注：默认安装都是最新版本，如需要安装指定版本，需要加上版本号<br>例如安装1.0.0版本<br>安装CPU版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install tensorflow==1.0.0</div></pre></td></tr></table></figure></p>
<p>安装GPU版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install tensorflow-gpu==1.0.0</div></pre></td></tr></table></figure></p>
<h1 id="通过源码安装"><a href="#通过源码安装" class="headerlink" title="通过源码安装"></a>通过源码安装</h1><pre><code>首先Mac下内置有gcc，可以通过终端命令gcc -v 查看：
</code></pre><p>其中的4.2.1就是gcc的版本，或者大家也可以直接输入终端命令python进行查看</p>
<p>里面有一个GCC 4.2.1，感觉比上面那个命令更直观一些。<br>然后就是要安装Google自家的编译工具bazel了，mac上最好的办法就是直接使用brew安装了：\<br>brew install bazel<br>安装好之后就要下载官方的TensorFlow源码了：<br>git clone <a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">https://github.com/tensorflow/tensorflow</a><br>下载完成后会在你的用户名的目录下生成一个tensorflow的文件夹，使用<br>cd tensorflow<br>进入这个文件夹，然后输入：<br>./configure<br>进行配置，通常情况下没有特殊的要求，一般全部都选择n，需要输入path的地方敲回车，使用默写path</p>
<p>配置完成后就是编译过程了，输入终端命令:<br>bazel build –config=opt //tensorflow/tools/pip_package:build_pip_package<br>经过漫长的编译后，任务就基本上完成了，接下来就是输入下面的命令来生成pip安装包了：<br>bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg<br>接下来安装这个wheel。如果之前pip装过tf的话，最好先卸载掉：<br>pip uninstall tensorflow<br>再安装<br>pip install /tmp/tensorflow_pkg/tensorflow-1.3.0-cp27-cp27m-macosx_10_12_intel.whl<br>安装成功<br>Installing collected packages: tensorflow<br>Successfully installed tensorflow-1.2.0<br>验证安装<br>遇到的问题：<br>如果错误是bazel相关的，请卸载bazel重新安装。</p>
]]></content>
      
        <categories>
            
            <category> TensorFlow </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python虚拟环境---virtualenv的安装及使用]]></title>
      <url>/2017/08/10/virtualenv-using-tutorial/</url>
      <content type="html"><![CDATA[<p>在开发 <strong><code>Python</code></strong> 应用程序的时候，系统安装的 <strong><code>Python</code></strong>只有一个版本，所有第三方的包都会被 <strong><code>pip</code></strong> 安装到 <strong><code>Python</code></strong> 的 <strong><code>site-packages</code></strong> 目录下。如果我们要同时开发多个应用程序，那这些应用程序都会共用这个安装在系统的 <strong><code>Python</code></strong>。如果 「应用A」 需要 <strong><code>Python 2.6</code></strong> 版本，而 「应用B」 需要 <strong><code>Python 2.7</code></strong> 版本，这种情况下共用这个安装在系统的 <strong><code>Python</code></strong> 版本就不能满足需求了，每个应用需要各自拥有一套「独立」的 <strong><code>Python</code></strong> 运行环境。<strong><code>virtualenv</code></strong> 就是用来为一个应用创建一套「独立」的 <strong><code>Python</code></strong> 运行环境，在虚拟环境下，用 <strong><code>pip</code></strong> 安装的包都被安装到虚拟环境 <strong><code>Python</code></strong> 的 <strong><code>site-packages</code></strong> 下，系统 <strong><code>Python</code></strong> 环境不受任何影响。<br><a id="more"></a></p>
<h1 id="安装「virtualenv」"><a href="#安装「virtualenv」" class="headerlink" title="安装「virtualenv」"></a>安装「virtualenv」</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install virtualenv</div></pre></td></tr></table></figure>
<p>查看 <strong><code>virtualenv</code></strong> 是否安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">virtualenv —version</div></pre></td></tr></table></figure></p>
<h1 id="创建「virtualenv」环境"><a href="#创建「virtualenv」环境" class="headerlink" title="创建「virtualenv」环境"></a>创建「virtualenv」环境</h1><p>切换到虚拟环境要存放的目录，创建虚拟环境:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">virtualenv &lt;env_name&gt;</div></pre></td></tr></table></figure></p>
<p>个人建议：</p>
<blockquote>
<p>虚拟环境与项目在同一目录下，并且虚拟环境以前缀 <strong><code>env_</code></strong> 加项目名来命名。<br>示例：<strong><code>machine_learning</code></strong> 是项目目录，<strong><code>env_machine_learning</code></strong> 是虚拟环境目录。</p>
</blockquote>
<h1 id="激活「virtualenv」环境"><a href="#激活「virtualenv」环境" class="headerlink" title="激活「virtualenv」环境"></a>激活「virtualenv」环境</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source &lt;env_name&gt;/bin/activate</div></pre></td></tr></table></figure>
<p>激活成功后，命令提示符有个(<strong><code>&lt;env_name&gt;</code></strong>)前缀，表示当前环境是一个名为 <strong><code>&lt;env_name&gt;</code></strong> 的 <strong><code>Python</code></strong> 虚拟环境。</p>
<h1 id="退出「virtualenv」环境"><a href="#退出「virtualenv」环境" class="headerlink" title="退出「virtualenv」环境"></a>退出「virtualenv」环境</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">deactivate</div></pre></td></tr></table></figure>
<p>退出成功后，命令提示符(<strong><code>&lt;env_name&gt;</code></strong>)前缀消失，此时就回到了正常的系统环境。</p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> virtualenv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[终端复用工具---「tmux」的安装及使用]]></title>
      <url>/2017/08/09/tmux-using-tutorial/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong><code>tmux</code></strong> 是一个优秀的终端复用软件，即使非正常掉线，也能保证当前的任务运行，这一点对于远程 <strong><code>ssh</code></strong> 访问特别有用，网络不好的情况下仍然能保证工作现场不丢失! <strong><code>tmux</code></strong>  完全使用键盘控制窗口，实现窗口的切换。<br><a id="more"></a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="在「Mac-OS」中安装"><a href="#在「Mac-OS」中安装" class="headerlink" title="在「Mac OS」中安装"></a>在「Mac OS」中安装</h2><h3 id="安装「Homebrew」"><a href="#安装「Homebrew」" class="headerlink" title="安装「Homebrew」"></a>安装「Homebrew」</h3><p>如果没有 <strong><code>homebrew</code></strong> ，先安装 <strong><code>homebrew</code></strong> ，如果已经安装，则跳过此步。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure></p>
<h3 id="安装「Tmux」"><a href="#安装「Tmux」" class="headerlink" title="安装「Tmux」"></a>安装「Tmux」</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install tmux</div></pre></td></tr></table></figure>
<h3 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h3><p>通过如下命令查看 <strong><code>tmux</code></strong> 的版本号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux -V</div></pre></td></tr></table></figure></p>
<p>当前安装版本为 <strong><code>2.6</code></strong>，则终端显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux 2.6</div></pre></td></tr></table></figure></p>
<h2 id="在「Ubuntu」中安装"><a href="#在「Ubuntu」中安装" class="headerlink" title="在「Ubuntu」中安装"></a>在「Ubuntu」中安装</h2><p>在终端输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install tmux</div></pre></td></tr></table></figure></p>
<h1 id="「Tmux」的配置文件"><a href="#「Tmux」的配置文件" class="headerlink" title="「Tmux」的配置文件"></a>「Tmux」的配置文件</h1><p><strong><code>tmux</code></strong> 的配置文件为 <strong><code>~/.tmux.conf</code></strong> ，每当开启一个新的会话时，<strong><code>tmux</code></strong>  都会先读取这个文件。</p>
<h1 id="「Tmux」的快捷键前缀-Prefix"><a href="#「Tmux」的快捷键前缀-Prefix" class="headerlink" title="「Tmux」的快捷键前缀(Prefix)"></a>「Tmux」的快捷键前缀(Prefix)</h1><p>为了使自身的快捷键和其他软件的快捷键互不干扰， <strong><code>tmux</code></strong> 提供了一个快捷键前缀(<strong><code>Prefix</code></strong>)，默认是组合键 <strong><code>Ctrl-b</code></strong>（同时按下 <strong><code>Ctrl</code></strong> 键和 <strong><code>b</code></strong> 键）<br>当想要使用快捷键时，需要先按下快捷键前缀，然后再按下快捷键，以下把前缀按键称为 <strong><code>Prefix</code></strong>。</p>
<p>下面介绍一下 <strong><code>tmux</code></strong> 的三个核心概念，会话(<strong><code>session</code></strong>)、窗口(<strong><code>window</code></strong>)和窗格(<strong><code>pane</code></strong>)及其基本用法。</p>
<h1 id="会话「session」"><a href="#会话「session」" class="headerlink" title="会话「session」"></a>会话「session」</h1><h2 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h2><p>创建一个新的会话，只需要在终端运行如下的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux new -s &lt;session_name&gt; -n &lt;window_name&gt;</div></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<blockquote>
<p><strong><code>-s</code></strong> 参数表示会话名称，如果不加 <strong><code>-s</code></strong> 参数，那么 <strong><code>tmux</code></strong> 默认会新建一个以数字(下标从 <strong><code>0</code></strong> 开始)命名的会话，并默认打开一个窗口。<br><strong><code>-n</code></strong> 参数表示默认打开的窗口的名称</p>
</blockquote>
<h2 id="重命名session"><a href="#重命名session" class="headerlink" title="重命名session"></a>重命名session</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + $ : 重命名当前的会话</div></pre></td></tr></table></figure>
<h2 id="断开session"><a href="#断开session" class="headerlink" title="断开session"></a>断开session</h2><p>想要暂时从 <strong><code>tmux</code></strong> 暂时分离，回到终端环境时，可以通过如下快捷键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + d : 断开当前的会话</div></pre></td></tr></table></figure></p>
<p>注意，即使是 <strong><code>detach</code></strong> 的状态，<strong><code>tmux</code></strong> 中在运行的程序还会继续运行</p>
<h2 id="回到session"><a href="#回到session" class="headerlink" title="回到session"></a>回到session</h2><p>想要回到 <strong><code>session</code></strong> 时，只需执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux attach -t &lt;session_name&gt;</div></pre></td></tr></table></figure></p>
<h2 id="列出session"><a href="#列出session" class="headerlink" title="列出session"></a>列出session</h2><p>在终端下，运行如下命令列出当前有多少个会话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux ls</div></pre></td></tr></table></figure></p>
<p>在会话中列出当前有多少个会话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + s : 列出所有会话</div></pre></td></tr></table></figure></p>
<h2 id="关闭session"><a href="#关闭session" class="headerlink" title="关闭session"></a>关闭session</h2><p>在终端下，要真正关闭一个会话，可以运行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux kill-session -t &lt;session_name&gt;</div></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<blockquote>
<p><strong><code>-t</code></strong> 参数表示会话名称。</p>
</blockquote>
<h1 id="窗口「window」"><a href="#窗口「window」" class="headerlink" title="窗口「window」"></a>窗口「window」</h1><p>如果说会话是个不可见的东西，那么窗口就是我们输入、执行命令的地方。一个会话 可以包含多个会话。</p>
<h2 id="创建window"><a href="#创建window" class="headerlink" title="创建window"></a>创建window</h2><p>在创建会话的时候默认会创建一个以 <strong><code>数字下标+bash</code></strong> 命名的窗口，并且名称随着 <strong><code>bash</code></strong> 中执行的不同命令而变化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + c : 创建一个新窗口</div></pre></td></tr></table></figure></p>
<h2 id="重命名window"><a href="#重命名window" class="headerlink" title="重命名window"></a>重命名window</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + , : 重命名当前窗口</div></pre></td></tr></table></figure>
<h2 id="切换window"><a href="#切换window" class="headerlink" title="切换window"></a>切换window</h2><p>同一个会话下的多个window之间切换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Prefix + p: 切换到上一个窗口。 </div><div class="line">Prefix + n: 切换到下一个窗口 。 </div><div class="line">Prefix + 0: 切换到0号window，依次类推，1、2、3... </div><div class="line">Prefix + w: 列出全部窗口，通过上、下键选择要进入的窗口，按回车键即可进入所选择的窗口中。</div></pre></td></tr></table></figure></p>
<h2 id="关闭window"><a href="#关闭window" class="headerlink" title="关闭window"></a>关闭window</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + &amp; : 关闭当前窗口。</div></pre></td></tr></table></figure>
<h1 id="窗格「pane」"><a href="#窗格「pane」" class="headerlink" title="窗格「pane」"></a>窗格「pane」</h1><p>一个窗口可以切割成多个窗格，也就是所谓的分屏。</p>
<h2 id="创建pane"><a href="#创建pane" class="headerlink" title="创建pane"></a>创建pane</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prefix + % : 垂直分屏，用一条垂线把当前窗口分成左右两屏。 </div><div class="line">Prefix + &quot; : 水平分屏，用一条水平线把当前窗口分成上下两屏。</div></pre></td></tr></table></figure>
<h2 id="切换pane"><a href="#切换pane" class="headerlink" title="切换pane"></a>切换pane</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Prefix + o : 依次切换当前窗口下的各个窗格。 </div><div class="line">Prefix + Up|Down|Left|Right : 根据按箭方向选择切换到某个窗格。 </div><div class="line">Prefix + Space(空格键): 对当前窗口下的所有窗格重新排列布局，每按一次，换一种样式。 </div><div class="line">Prefix + z : 最大化当前窗格。再按一次后恢复。</div></pre></td></tr></table></figure>
<h2 id="关闭pane"><a href="#关闭pane" class="headerlink" title="关闭pane"></a>关闭pane</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + x : 关闭当前使用中的窗格。</div></pre></td></tr></table></figure>
<h2 id="其他pane快捷键"><a href="#其他pane快捷键" class="headerlink" title="其他pane快捷键"></a>其他pane快捷键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Prefix + q : 显示窗格的编号</div><div class="line">Prefix + &#125; : 与下一个窗格交换位置</div><div class="line">Prefix + &#123; : 与上一个窗格交换位置</div><div class="line">Prefix + ! : 在新窗口中显示当前窗格</div><div class="line">Prefix + t : 在当前窗格显示时间</div></pre></td></tr></table></figure>
<h1 id="滚屏"><a href="#滚屏" class="headerlink" title="滚屏"></a>滚屏</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + [ : 滚屏</div></pre></td></tr></table></figure>
<p>滚屏要进入 <strong><code>copy-mode</code></strong>，然后就可以用上下键来滚动屏幕，配置了 <strong><code>vi</code></strong> 快捷键模式，就可以像操作 <strong><code>vi</code></strong> 一样来滚动屏幕，非常的方便。 退出直接回车键或 <strong><code>q</code></strong>键即可退出</p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux, tmux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git常用命令教程]]></title>
      <url>/2017/08/05/git-command-tutorial/</url>
      <content type="html"><![CDATA[<h1 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h1><h2 id="Git-介绍"><a href="#Git-介绍" class="headerlink" title="Git 介绍"></a>Git 介绍</h2><p><a href="https://git-scm.com/" target="_blank" rel="external">Git</a> 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<code>Git</code>的读音为/gɪt/。<code>Git</code> 是 <code>Linus Torvalds</code> 为了帮助管理 <code>Linux</code> 内核开发而开发的一个开放源码的版本控制软件。</p>
<h2 id="什么文件可以被-Git-管理"><a href="#什么文件可以被-Git-管理" class="headerlink" title="什么文件可以被 Git 管理?"></a>什么文件可以被 Git 管理?</h2><p>文本文件(.txt)，脚本文件(.py等)，各种基于文本信息的文件.</p>
<h2 id="什么文件不能被-Git-管理"><a href="#什么文件不能被-Git-管理" class="headerlink" title="什么文件不能被 Git 管理?"></a>什么文件不能被 Git 管理?</h2><p>图片文件(.jpg等)，PDF(.pdf)，MS Word(.doc)，MS Power Point(.ppt)，MS Excel(.xls)等。<br><a id="more"></a></p>
<h2 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h2><h3 id="Git-直接记录快照，而非差异比较"><a href="#Git-直接记录快照，而非差异比较" class="headerlink" title="Git 直接记录快照，而非差异比较"></a><code>Git</code> 直接记录快照，而非差异比较</h3><p><code>Git</code> 和其它版本控制系统（包括 <code>Subversion</code> 等）的主要差别在于 <code>Git</code> 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 这类系统（<code>CVS</code>、<code>Subversion</code>、<code>Perforce</code>、<code>Bazaar</code> 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。<br><code>Git</code> 不按照以上方式对待或保存数据。 反之，<code>Git</code> 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 <code>Git</code> 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，<code>Git</code> 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 <code>Git</code> 对待数据更像是一个「快照流」。<br>这是 <code>Git</code> 与几乎所有其它版本控制系统的重要区别。 因此 <code>Git</code> 重新考虑了以前每一代版本控制系统延续下来的诸多方面。<code>Git</code> 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 <code>VCS</code>。</p>
<h3 id="Git-不需要联网就能工作"><a href="#Git-不需要联网就能工作" class="headerlink" title="Git 不需要联网就能工作"></a><code>Git</code> 不需要联网就能工作</h3><p>在 <code>Git</code> 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息，由于本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。而其他集中式版本控制系统(例如 <code>SVN</code>等)，必须联网才能工作， 所有操作都有网络延时开销。</p>
<h3 id="Git-保证完整性"><a href="#Git-保证完整性" class="headerlink" title="Git 保证完整性"></a><code>Git</code> 保证完整性</h3><p><code>Git</code> 的内容完整性要优于其他集中式版本控制系统(例如 <code>SVN</code>等)。<code>Git</code> 中所有数据在存储前都计算校验和，然后以校验和来引用。这个功能建构在 <code>Git</code> 底层，是构成 <code>Git</code> 哲学不可或缺的部分。 若在传送过程中丢失信息或损坏文件，<code>Git</code> 就能发现。<code>Git</code> 用以计算校验和的机制叫做 <code>SHA-1</code> 哈希散列。 这是一个由40个十六进制字符(<code>0-9</code> 和 <code>a-f</code>)组成字符串，基于 <code>Git</code> 中文件的内容或目录结构计算出来。 <code>SHA-1</code> 哈希看起来是这样：<code>24b9da6552252987aa493b52f8696cd6d3b00373</code>，<code>Git</code> 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，<code>Git</code>  数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<h3 id="Git-一般只添加数据"><a href="#Git-一般只添加数据" class="headerlink" title="Git 一般只添加数据"></a><code>Git</code> 一般只添加数据</h3><p><code>Git</code> 操作，几乎只往 <code>Git</code> 数据库中增加数据。 很难让 <code>Git</code> 执行任何不可逆操作，或者让它以任何方式清除数据。 同别的 <code>VCS</code> 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 <code>Git</code> 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。这使得在使用 <code>Git</code> 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。</p>
<h1 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h1><p>最早 <code>Git</code> 是在 <code>Linux</code> 上开发的，很长一段时间内，<code>Git</code> 也只能在 <code>Linux</code> 和 <code>Unix</code> 系统上跑。目前，<code>Git</code> 已经可以在 <code>Linux</code>、<code>Unix</code>、<code>Mac</code> 和 <code>Windows</code> 几大平台上运行。详细的安装说明请前往<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" target="_blank" rel="external"> Git官网安装说明 </a>查看， <code>Git</code> 在每种系统上的安装方式各不相同，安装步骤分别如下:</p>
<h2 id="Linux平台上安装"><a href="#Linux平台上安装" class="headerlink" title="Linux平台上安装"></a>Linux平台上安装</h2><p>打开 <code>terminal</code>，可以用下面的命令安装：</p>
<h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> apt-get install git-all</div></pre></td></tr></table></figure>
<p>使用 <code>git --version</code> 查看是否安装成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git --version</div><div class="line">git version 2.7.4</div></pre></td></tr></table></figure></p>
<h3 id="Centos-RedHat"><a href="#Centos-RedHat" class="headerlink" title="Centos/RedHat"></a>Centos/RedHat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> yum -y install git-all</div></pre></td></tr></table></figure>
<p>使用 <code>git --version</code> 查看是否安装成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git --version</div><div class="line">git version 1.7.1</div></pre></td></tr></table></figure></p>
<h2 id="Mac-平台上安装"><a href="#Mac-平台上安装" class="headerlink" title="Mac 平台上安装"></a>Mac 平台上安装</h2><p>1、先下载 <code>.dmg</code> 安装包，下载地址为：<a href="https://git-scm.com/download/mac" target="_blank" rel="external">https://git-scm.com/download/mac</a> ，点击下载到本地，下载文件例如：<code>git-2.14.1-intel-universal-mavericks.dmg</code><br>2、双击安装包进行安装即可<br>3、使用 <code>git --version</code> 查看是否安装成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git --version</div><div class="line">git version 2.14.1</div></pre></td></tr></table></figure></p>
<h2 id="Windows-平台上安装"><a href="#Windows-平台上安装" class="headerlink" title="Windows 平台上安装"></a>Windows 平台上安装</h2><p>1、先下载 <code>.exe</code> 安装包，下载地址为：<a href="https://git-scm.com/download/win" target="_blank" rel="external">https://git-scm.com/download/win</a> ，选择适合当前系统的版本，点击下载到本地<br>2、双击安装包进行安装即可<br>3、在开始菜单里找到<code>Git</code>-&gt;<code>Git Bash</code>，会弹出 <code>Git</code> 命令窗口，使用 <code>git --version</code> 查看是否安装成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git version</div><div class="line">git version 2.14.2.windows.1</div></pre></td></tr></table></figure></p>
<h1 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h1><p>安装 <code>Git</code> 后，每台计算机上只需要进行一次配置，程序升级时会保留配置信息。你可以在任何时候再次通过运行命令来修改它们。<br><code>Git</code> 自带一个 <code>git config</code> 的工具，专门用来配置或读取相应的工作环境变量。这些变量存储在三个不同的位置：</p>
<ul>
<li><code>/etc/gitconfig</code> 文件： 包含系统上每一个用户及他们仓库的通用配置，如果使用带有 <code>--system</code> 选项的 <code>git config</code> 时，它会从此文件读写配置变量。</li>
<li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户，可以传递 <code>--global</code> 选项让 <code>Git</code> 读写此文件。</li>
<li>当前使用仓库的 <code>Git</code> 目录中的 <code>config</code> 文件(就是 <code>.git/config</code>)：针对该仓库。</li>
</ul>
<p>每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。</p>
<p>在 <code>Windows</code> 系统中，<code>Git</code> 会查找 <code>$HOME</code> 目录下（一般情况下是 <code>C:\Users\$USER</code>）的 <code>.gitconfig</code> 文件。 <code>Git</code> 同样也会寻找 <code>/etc/gitconfig</code> 文件，但只限于 <code>MSys</code> 的根目录下，即安装 <code>Git</code> 时所选的目标位置。</p>
<h2 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h2><p>当安装完 <code>Git</code> 应该做的第一件事就是设置个人的「用户名称」与「邮件地址」。 这样做很重要，因为每一个 <code>Git</code> 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git config --global user.name lichengjin</div><div class="line"><span class="meta">$</span> git config --global user.email lichengjin606@gmail.com</div></pre></td></tr></table></figure></p>
<p>再次强调，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，<code>Git</code> 都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code>选项的命令来配置，新的设定保存在当前项目的 <code>.git/config</code> 文件里。</p>
<h2 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h2><p>要检查已有的配置信息，可以使用 <code>git config --list</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git config --list</div><div class="line">user.name=lichengjin</div><div class="line">user.email=lichengjin606@gmail.com</div></pre></td></tr></table></figure></p>
<p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 <code>/etc/gitconfig</code> 和 <code>~/.gitconfig</code>），不过最终 <code>Git</code> 实际采用的是最后一个。<br>这些配置我们也可以在 <code>~/.gitconfig</code> 或 <code>/etc/gitconfi</code> 看到，如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> vim ~/.gitconfig</div></pre></td></tr></table></figure></p>
<p>显示内容如下所示：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[user]</div><div class="line">    	name = lichengjin</div><div class="line">    	email = lichengjin606@gmail.<span class="keyword">com</span></div></pre></td></tr></table></figure></p>
<p>你可以通过输入 <code>git config &lt;key&gt;</code> 来检查 <code>Git</code>的某一项配置，例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git config user.name</div><div class="line">lichengjin</div></pre></td></tr></table></figure></p>
<h1 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h1><p><code>Git</code> 的工作流程如下：</p>
<ol>
<li>克隆 <code>Git</code> 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>
</ol>
<p>下图展示了 <code>Git</code> 的工作流程，图片来自<a href="http://www.runoob.com/git/git-workflow.html" target="_blank" rel="external">菜鸟教程</a>：<br><img src="/images/git/git_process.jpg" alt="Git 工作流程图"></p>
<h1 id="Git-工作区，暂存区和版本库"><a href="#Git-工作区，暂存区和版本库" class="headerlink" title="Git 工作区，暂存区和版本库"></a>Git 工作区，暂存区和版本库</h1><p>工作区：就是你在电脑里能看到的目录。是对项目的某个版本独立提取出来的内容。 这些从 <code>Git</code> 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。<br>暂存区：英文叫<code>stage</code>， 或<code>index</code>。是一个文件，一般存放在 <code>.git/index</code> 中，保存了下次将提交的文件列表信息，有时候也被称作索引( <code>index</code> )。<br>版本库：版本库又名仓库，英文名<code>repository</code>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被 <code>Git</code> 管理起来，每个文件的修改、删除，<code>Git</code> 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原。工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 <code>Git</code> 的版本库，是 <code>Git</code> 用来保存项目的元数据和对象数据库的地方。 这是 <code>Git</code> 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。<br>下面这个图展示了「工作区」、「暂存区」和「版本库」之间的关系，图片来自<a href="http://www.runoob.com/git/git-workspace-index-repo.html" target="_blank" rel="external">菜鸟教程</a>：<br><img src="/images/git/git_work_stage_respository.jpg" alt="工作区、暂存区和版本库之间的关系"><br>图中左侧为「工作区」，右侧为「版本库」。在「版本库」中标记为 <code>index</code> 的区域是「暂存区」(<code>stage</code>，<code>index</code>)，标记为 <code>master</code> 的是 <code>master</code> 分支所代表的目录树。<br>图中我们可以看出此时 <code>HEAD</code> 实际是指向 <code>master</code> 分支的一个「游标」。所以图示的命令中出现 <code>HEAD</code> 的地方可以用 <code>master</code> 来替换。<br>图中的 <code>objects</code> 标识的区域为 <code>Git</code> 的「对象库」，实际位于 <code>.git/objects</code> 目录下，里面包含了创建的各种对象及内容。<br>当对「工作区」修改或新增的文件执行 <code>git add</code> 命令时，「暂存区」的目录树被更新，同时「工作区」修改或新增的文件内容被写入到「对象库」中的一个新的对象中，而该对象的 <code>ID</code> 被记录在暂存区的文件索引中。<br>当执行提交操作 <code>git commit</code> 时，「暂存区」的目录树写到「版本库」中，<code>master</code> 分支会做相应的更新。即 <code>master</code> 指向的目录树就是提交时「暂存区」的目录树。<br>当执行 <code>git reset HEAD</code> 命令时，「暂存区」的目录树会被重写，被 <code>master</code> 分支指向的目录树所替换，但是「工作区」不受影响。<br>当执行 <code>git rm --cached &lt;file&gt;</code> 命令时，会直接从「暂存区」删除文件，「工作区」则不做出改变。<br>当执行 <code>git checkout .</code> 或者 <code>git checkout -- &lt;file&gt;</code> 命令时，会用「暂存区」全部或指定的文件替换「工作区」的文件。这个操作很危险，会清除「工作区」中未添加到「暂存区」的改动。<br>当执行 <code>git checkout HEAD .</code> 或者 <code>git checkout HEAD &lt;file&gt;</code> 命令时，会用 <code>HEAD</code> 指向的 <code>master</code> 分支中的全部或者部分文件替换「暂存区」和以及「工作区」中的文件。这个命令也是极具危险性的，因为不但会清除「工作区」中未提交的改动，也会清除「暂存区」中未提交的改动。</p>
<h1 id="获取版本库"><a href="#获取版本库" class="headerlink" title="获取版本库"></a>获取版本库</h1><h2 id="创建新的版本库"><a href="#创建新的版本库" class="headerlink" title="创建新的版本库"></a>创建新的版本库</h2><p>1、 选择一个合适的地方，创建一个空目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> mkdir git_tutorial</div><div class="line"><span class="meta">$</span> cd git_tutorial</div><div class="line"><span class="meta">$</span> pwd</div><div class="line">/Users/lichengjin/workspace/git_tutorial</div></pre></td></tr></table></figure>
<p>2、 通过 <code>git init</code> 命令把这个目录变成 <code>Git</code> 可以管理的仓库:<br>注：如果打算使用 <code>Git</code> 来对现有的项目进行管理，只需要进入该项目目录并输入<code>git init</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git init</div><div class="line">Initialized empty Git repository in /Users/lichengjin/workspace/git_tutorial/.git/</div></pre></td></tr></table></figure>
<p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 <code>Git</code> 仓库中所有的必须文件，这些文件是 <code>Git</code> 仓库的骨干，是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。<br>如果你没有看到 <code>.git</code> 目录，那是因为这个目录默认是隐藏的，用 <code>ls -a</code> 命令查看即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ls -a</div><div class="line">.    ..   .git</div></pre></td></tr></table></figure></p>
<h2 id="克隆现有的版本库"><a href="#克隆现有的版本库" class="headerlink" title="克隆现有的版本库"></a>克隆现有的版本库</h2><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 <code>git clone</code> 命令。 如果你对其它的 <code>VCS</code> 系统（比如说 <code>Subversion</code> ）很熟悉，请留心一下你所使用的命令是 <code>clone</code> 而不是 <code>checkout</code>。 这是 <code>Git</code> 区别于其它版本控制系统的一个重要特性，<code>Git</code> 克隆的是该 <code>Git</code> 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 <code>git clone</code> 命令的时候，默认配置下远程 <code>Git</code> 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库(虽然可能会丢失某些服务器端的挂钩设置，但是所有版本的数据仍在)。</p>
<p>克隆仓库的命令格式：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone &lt;repo&gt;</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/ChengjinLi/machine_learning.git</div></pre></td></tr></table></figure></p>
<p>如果我们需要克隆到指定的目录，可以使用以下命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone &lt;repo&gt; &lt;directory&gt;</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/ChengjinLi/machine_learning.git mj_machine_learning</div></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li>repo：Git 仓库。</li>
<li>directory：本地目录。</li>
</ul>
<p><code>Git</code> 支持多种数据传输协议。 上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 <code>SSH</code> 传输协议。</p>
<h1 id="Git-文件生命周期"><a href="#Git-文件生命周期" class="headerlink" title="Git 文件生命周期"></a>Git 文件生命周期</h1><p>请记住，「工作目录」下的每一个文件都不外乎这两种状态：「已跟踪」或「未跟踪」。「已跟踪」的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于「未修改」，「已修改」或「已放入暂存区」。 「工作目录」中除「已跟踪」文件以外的所有其它文件都属于「未跟踪」文件，它们既不存在于上次快照的记录中，也没有放入「暂存区」。 初次克隆某个仓库的时候，「工作目录」中的所有文件都属于「已跟踪」文件，并处于「未修改」状态。编辑过某些文件之后，由于自上次提交后你对它们做了修改，<code>Git</code> 将它们标记为「已修改」文件。 我们逐步将这些修改过的文件放入「暂存区」，然后提交所有暂存了的修改，如此反复。<br>使用 <code>Git</code> 时文件的生命周期如下：<br><img src="/images/git/git_life_cycle.jpg" alt="Git 文件生命周期"></p>
<h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><p><strong><code>git add &lt;file_name&gt;/&lt;dir_name&gt;</code></strong><br>将文件添加到暂存区，参数可以是指定路径的文件名或目录的名字，也可以使用 glob 模式。</p>
<p><strong><code>git status</code></strong><br>查看项目的当前状态，输出详细内容<br><strong><code>git status --short</code></strong> 或 <strong><code>git status -s</code></strong><br>查看项目的当前状态，以简短的结果输出<br>状态说明：</p>
<ul>
<li>?? 未跟踪的文件</li>
<li>M：修改过的文件，出现在靠左边的<code>M</code>表示该文件被修改了并放入了暂存区，出现在右边的<code>M</code>表示该文件被修改了但是还没放入暂存区，</li>
<li>A：新添加到暂存区的文件</li>
<li>D：已删除(deleted)</li>
<li>R：重命名(renamed)</li>
<li>C：已拷贝(copied)</li>
<li>U：已更新但为合并(updated but unmerged)</li>
</ul>
<p><strong><code>git diff</code></strong><br>查看尚未 <code>add</code> 的所有文件的改动和上个已经 <code>commit</code>的文件的不同<br><strong><code>git diff &lt;file_name&gt;</code></strong><br>查看尚未 <code>add</code> 的 <code>&lt;file_name&gt;</code> 文件的改动和上个已经 <code>commit</code>的文件的不同<br><strong><code>git diff --cached</code></strong><br>查看已经 <code>add</code> 的文件的改动<br><strong><code>git diff HEAD</code></strong><br>查看已 <code>add</code> 的与未 <code>add</code> 的所有改动<br><strong><code>git diff --stat</code></strong><br>显示摘要而非整个<code>diff</code></p>
<p><strong><code>git commit -m &quot;message&quot;</code></strong><br>将暂存区的文件提交到版本库，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，最好是有意义的，方便从历史记录找到改动记录。<br><strong><code>git commit --amend --no-edit</code></strong><br>将本次改动直接合并到上一个 <code>commit</code> 中<br><strong><code>git commit -am &quot;message&quot;</code></strong><br>跳过使用暂存区的方式，自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</p>
<p><strong><code>git rm &lt;file_name&gt;/&lt;dir_name&gt;</code></strong><br>将文件从暂存区域移除，参数可以是指定路径的文件名或目录的名字，也可以使用 glob 模式。<br><strong><code>git rm --cached &lt;file_name&gt;/&lt;dir_name&gt;</code></strong><br>将文件从 <code>Git</code> 仓库中删除，但仍然希望保留在当前工作目录中，参数可以是指定路径的文件名或目录的名字，也可以使用 glob 模式。</p>
<p><strong><code>git mv &lt;file_from&gt; &lt;file_to&gt;</code></strong><br>将 <code>Git</code> 中的 <code>&lt;file_from&gt;</code> 重命名为 <code>&lt;file_to&gt;</code></p>
<p><strong><code>git log</code></strong><br>查看历史提交记录，显示从最近到最远的提交日志<br><strong><code>git log --oneline</code></strong><br>一行显示一次提交<br><strong><code>git log --oneline --graph</code></strong><br>查看历史中什么时候出现了分支、合并，开启了拓扑图选项<br><strong><code>git log --author=&lt;user_name&gt;</code></strong><br>查找指定用户 <code>&lt;user_name&gt;</code> 的提交日志</p>
<p><strong><code>git reflog</code></strong><br>查看历史命令记录，显示从最近到最远的日志</p>
<p><strong><code>git reset HEAD</code></strong><br>取消已缓存的内容，即取消之前 <code>git add</code> 添加的内容<br>在 <code>Git</code> 中，用 <code>HEAD</code> 表示当前版本，上一个版本就是 <code>HEAD^</code> ，上上一个版本就是 <code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成 <code>HEAD~100</code>。<br><strong><code>git reset &lt;file_name&gt;</code></strong><br>取消已缓存的<code>&lt;file_name&gt;</code>，即取消之前 <code>git add</code> 添加的内容<br><strong><code>git reset --hard &lt;commit_id&gt;</code></strong><br>回退到指定 <code>&lt;commit_id&gt;</code> 版本，<code>&lt;commit_id&gt;</code>没必要写全，前位(例如前7位)就可以了，<code>Git</code> 会自动去找，当然也不能只写前一两位，因为 <code>Git</code> 可能会找到多个版本号，就无法确定是哪一个了。</p>
<p><strong><code>git checkout &lt;commid_id&gt; -- &lt;file_name&gt;</code></strong><br>将 <code>&lt;file_name&gt;</code> 回退到 <code>&lt;commid_id&gt;</code> 的版本<br><strong><code>git checkout &lt;branch_name&gt;</code></strong><br>将 <code>HEAD</code> 从当前分支切换到 <code>&lt;branch_name&gt;</code> 分支<br><strong><code>git checkout -b &lt;branch_name&gt;</code></strong><br>创建 <code>&lt;branch_name&gt;</code> 分支，并切换到新建的分支</p>
<p><strong><code>git branch</code></strong><br>查看当前分支，<code>*</code>代表了当前 <code>HEAD</code> 所在的分支<br><strong><code>git branch &lt;branch_name&gt;</code></strong><br>创建 <code>&lt;branch_name&gt;</code> 分支</p>
<p><strong><code>git merge &lt;branch_name&gt;</code></strong><br>将 <code>&lt;branch_name&gt;</code> 合并到当前分支，<code>Git</code> 会采用默认的 <code>Fast forward</code> 格式进行合并，这次合并操作不会有 <code>commit</code> 信息，<code>log</code> 中也不会有分支的图案。<br><strong><code>git merge --no-diff -m &quot;message&quot; &lt;branch_name&gt;</code></strong><br>采取 <code>--no-ff</code> 这种方式保留合并的 <code>commit</code> 信息。</p>
<h1 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h1><p>一般我们总会有些文件无需纳入 <code>Git</code> 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为<code>.gitignore</code> 的文件，列出要忽略的文件模式。要养成一开始就设置好 <code>.gitignore</code> 文件的习惯，以免将来误提交这类无用的文件。<br>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>＃</code> 开头的行都会被 <code>Git</code> 忽略。</li>
<li>可以使用标准的 <code>glob</code> 模式匹配。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
<p>所谓的 <code>glob</code> 模式是指 <code>shell</code> 所使用的简化了的正则表达式。 星号<code>*</code>匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 <code>a</code>，要么匹配一个 <code>b</code>，要么匹配一个 <code>c</code>）；问号<code>?</code>只匹配一个任意字符；如果在方括号中使用短划线<code>-</code>分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有<code>0</code>到<code>9</code>的数字）。 使用两个星号<code>*</code>表示匹配任意中间目录，比如<code>a/**/z</code> 可以匹配 <code>a/z</code>, <code>a/b/z</code> 或 <code>a/b/c/z</code>等。<code>GitHub</code> 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表，你可以在 <a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a> 找到它.</p>
<h1 id="Github-使用"><a href="#Github-使用" class="headerlink" title="Github 使用"></a>Github 使用</h1><p><a href="https://github.com/" target="_blank" rel="external">Github</a> 是一个大家都积极贡献的地方， 你可以和各种人合作创作，也是开源的天堂， 只要你愿意, 任何人都能下载, 或修改你的杰作。<br>在<code>Github</code> 上注册一个账户<br>然后添加一个 <code>online</code> 版本库 <code>repository</code><br>连接本地版本库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add [alias] [url]</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git remote add origin https://github.com/ChengjinLi/machine_learning.git</div><div class="line"><span class="meta">$</span> git push -u origin master     # 推送本地 master 去 origin</div></pre></td></tr></table></figure></p>
<p>在执行 <code>commit</code> 之后，可以执行 <code>git push -u origin master</code> 将本地修改提交到 <code>Github</code></p>
<p>要查看当前配置有哪些远程仓库，可以用命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git remote</div><div class="line">origin</div></pre></td></tr></table></figure></p>
<p>执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git remote -v</div><div class="line">origin	https://github.com/ChengjinLi/machine_learning.git (fetch)</div><div class="line">origin	https://github.com/ChengjinLi/machine_learning.git (push)</div></pre></td></tr></table></figure></p>
<p>删除别名为 <code>&lt;alias&gt;</code> 的远程仓库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git remote rm &lt;alias&gt;</div></pre></td></tr></table></figure></p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>Git 官网： <a href="https://git-scm.com/" target="_blank" rel="external">https://git-scm.com/</a><br>Git 完整命令手册地址： <a href="http://git-scm.com/docs" target="_blank" rel="external">http://git-scm.com/docs</a><br>Pro Git book： <a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">https://git-scm.com/book/zh/v2</a><br>廖雪峰Git教程：<br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a><br>菜鸟Git教程： <a href="http://www.runoob.com/git/git-tutorial.html" target="_blank" rel="external">http://www.runoob.com/git/git-tutorial.html</a><br>Github 官网： <a href="https://github.com/" target="_blank" rel="external">https://github.com/</a></p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vim常用命令教程]]></title>
      <url>/2017/08/04/vim-command-tutorial/</url>
      <content type="html"><![CDATA[<p><code>vim</code> 的配置文件在根目录的 <code>.vimrc</code> 文件中，如果没有，自己创建一个。<br><a id="more"></a><br>打开 <code>.vimrc</code> 文件，输入配置，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">set paste    &quot; 进入paste模型</div><div class="line">set number     &quot; 显示行号</div><div class="line">set tabstop=4     　&quot; 一个tab为4个空格长度</div><div class="line">set shiftwidth=4     &quot; 将换行自动缩进设置成4个空格</div><div class="line">set expandtab     &quot; 输入tab时自动将其转化为空格</div><div class="line">set sts=4     &quot; 敲入tab键时实际占有的列数</div><div class="line">set autoindent     &quot; 设置自动缩进</div><div class="line">set smartindent    &quot; 智能缩进</div><div class="line">set mouse=a    &quot; 鼠标可用</div><div class="line">syntax on     &quot; 语法高亮</div><div class="line">set hlsearch    &quot; 开启查找匹配的高亮显示, 简写set hls</div><div class="line">&quot; set nohlsearch     &quot; 关闭查找匹配的高亮显示, 简写set nohls</div><div class="line">set encoding=utf-8     &quot; 屏幕显示的编码</div><div class="line">set fileencoding=utf-8     &quot; 正在被编辑的文件的编码</div><div class="line">set fileencodings=ucs-bom,utf-8,cp936,gbk,gb2312</div><div class="line">set termencoding=utf-8</div><div class="line">set showmatch    &quot; 括号匹配  </div><div class="line">set ruler     &quot; 右下角显示光标状态行  </div><div class="line">set incsearch     &quot; 设置快速搜索  </div><div class="line">set foldenable     &quot; 开启代码折叠  </div><div class="line">set fdm=manual     &quot; 手动折叠 </div><div class="line">set foldmethod=syntax     &quot; 自动语法折叠  </div><div class="line">set modeline     &quot; 自动载入模式行</div><div class="line">set cursorline     &quot; 开启光亮光标行</div><div class="line">set cursorcolumn     &quot; 开启光亮光标列</div><div class="line"></div><div class="line">&quot; vundle 环境设置</div><div class="line">filetype off</div><div class="line">set rtp+=~/.vim/bundle/Vundle.vim</div><div class="line"> vundle 管理的插件列表必须位于 vundle#begin() 和 vundle#end() 之间</div><div class="line">call vundle#begin()</div><div class="line">Plugin &apos;altercation/vim-colors-solarized&apos;</div><div class="line">Plugin &apos;tomasr/molokai&apos;</div><div class="line">Plugin &apos;vim-scripts/phd&apos;</div><div class="line">Plugin &apos;Lokaltog/vim-powerline&apos;</div><div class="line">Plugin &apos;octol/vim-cpp-enhanced-highlight&apos;</div><div class="line">Plugin &apos;Raimondi/delimitMate&apos;</div><div class="line">Plugin &apos;scrooloose/nerdtree&apos;</div><div class="line">Plugin &apos;vim-scripts/indentpython.vim&apos;</div><div class="line">Plugin &apos;davidhalter/jedi-vim&apos;</div><div class="line">&quot;Plugin &apos;w0rp/ale&apos;</div><div class="line">Plugin &apos;Shougo/neocomplete.vim&apos;</div><div class="line">Plugin &apos;majutsushi/tagbar&apos;</div><div class="line">&quot; 插件列表结束</div><div class="line">call vundle#end()</div><div class="line">filetype plugin indent on</div><div class="line"></div><div class="line">map &lt;F3&gt; :nohlsearch&lt;CR&gt;    &quot; 绑定快捷键来去掉当前显示的高亮（一次性）</div><div class="line">:set pastetoggle=&lt;F10&gt;    &quot; 绑定快捷键来激活/取消 paste模式</div><div class="line">nnoremap &lt;silent&gt; &lt;F11&gt; :AV&lt;CR&gt; </div><div class="line">map &lt;F12&gt; :q&lt;CR&gt;    &quot; 绑定快捷键来退出当前vim编辑：</div></pre></td></tr></table></figure></p>
<p>设置说明：</p>
<p>set shiftwidth(简写：sw)</p>
<p>这个是用于程序中自动缩进所使用的空白长度。一般来说为了保持程序的美观，和下面的参数最好一致。同时它也是符号移位长度的制定者。</p>
<p>set tabstop(简写：ts)</p>
<p>定义tab所等同的空格长度，linux 内核代码建议每个tab占用8列，因为如果是其它值的话，可能引起文件在打印之类的场合中看起来很别扭。</p>
<p>set expandtab(简写：et)</p>
<p>输入tab时自动将其转化为空格，这样的话就不会一起混淆，不过毕竟制表符为8是最常用最普遍的设置，所以一般还是不要改。<br>举个例子，在多人一起开发项目时，为了使代码风格尽量保持一致，一般不允许在代码使用TAB符，而以4个空格代之。</p>
<p>set softtabstop(简写：sts)</p>
<p>敲入tab键时实际占有的列数。如果我们希望改变程序中的缩进怎么办？shiftwidth和tabstop不一样的话，你会发现程序比较难看的。这时候，softtabstop就起作用了。可以从vim的说明中看到，一旦设置了softtabstop的值时，你按下tab键，插入的是空格和tab制表符的混合，具体如何混合取决于你设定的softtabstop，举个例子，如果设定softtabstop=8, 那么按下tab键，插入的就是正常的一个制表符;如果设定 softtabstop=16,那么插入的就是两个制表符；如果softtabstop=12,那么插入的就是一个制表符加上4个空格；如果softtabstop=4呢？那么一开始，插入的就是4个空格，此时一旦你再按下一次tab，这次的四个空格就会和上次的四个空格组合起来变成一个制表符。换句话说，softtabstop是“逢8空格进1制表符”,前提是你tabstop=8。</p>
<p>set number(简写：nu)</p>
<p>显示行号</p>
<p>set nonumber(简写：nonu)</p>
<p>关闭行号显示</p>
<p>set ruler</p>
<p>设置在窗口右下角显示行号，与上面的好处是，节省空间</p>
<p>set autoindent(简写：ai)</p>
<p>设置自动缩进</p>
<p>syntax on</p>
<p>语法高亮</p>
<p>set smartindent </p>
<p>智能缩进</p>
<p>set encoding</p>
<p>屏幕显示的编码，目前大部分Linux系统已经将utf-8作为默认locale，encoding就应是utf-8以方便显示。该选项使用于缓冲的文本(你正在编辑的文件)，寄存器，Vim 脚本文件等等。你可以把 ‘encoding’ 选项当作是对 Vim 内部运行机制的设定。 </p>
<p>set fileencoding</p>
<p>正在被编辑的文件的编码，它也决定新文件的编码。如果为空，表示与encoding相同。如果与encoding不同，vi将会在保存和读取时做二者之间的转换。</p>
<p>set fileencodings</p>
<p>供vim尝试的编码列表，vi会逐个尝试每一项，如果没有发生错误，就设置当前的fileencoding为与该项相同的值。如果均失败，fileencoding将为空。</p>
<p>set termencoding</p>
<p>输出到客户终端（Term）采用的编码类型，默认空值，也就是输出到终端不进行编码转换。 </p>
<p>set showmatch</p>
<p>括号匹配  </p>
<p>set ruler</p>
<p>右下角显示光标状态行  </p>
<p>set incsearch</p>
<p>设置快速搜索  </p>
<p>set foldenable</p>
<p>开启代码折叠  </p>
<p>set fdm=manual</p>
<p>手动折叠 </p>
<p>set foldmethod=syntax</p>
<p>自动语法折叠  </p>
<p>set modeline</p>
<p>自动载入模式行</p>
<p>set ignorecase</p>
<p>大小写无关</p>
<p>set noignorecase</p>
<p>大小写敏感</p>
<p>set hlsearch</p>
<p>开启查找匹配的高亮显示, 简写set hls</p>
<p>set nohlsearch</p>
<p>关闭查找匹配的高亮显示, 简写set nohls  </p>
<p>:nohlsearch</p>
<p>去掉当前显示的高亮（一次性）</p>
<p>:set paste</p>
<p>进入paste模型,进入 paste 模式后，按 i 键进入插入模式，然后再粘帖，文本格式不会错乱了。但粘帖后还需要按 <esc> </esc></p>
<p>进入普通模式并执行如下命令结束 paste 模式：</p>
<p>:set nopaste</p>
<p>结束 paste 模式</p>
<p>:set pastetoggle=<f10\></f10\></p>
<p>paste有一个切换paste开关的选项，这就是pastetoggle。通过它可以绑定快捷键来激活/取消 paste模式</p>
<p>vim 的插件使用 vundle 管理：</p>
<p>安装 vundle：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</div></pre></td></tr></table></figure></p>
<p>安装插件，先找到其在 github.com 的地址，再将配置信息加入 .vimrc 中的call vundle#begin() 和 call vundle#end() 之间，如我的配置文件所示，Plugin ‘插件地址’ 即为添加插件，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plugin &apos;majutsushi/tagbar&apos;</div></pre></td></tr></table></figure></p>
<p>最后进入 vim 执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:PluginInstall</div></pre></td></tr></table></figure></p>
<p>便安装完成插件。</p>
<p>如需删除插件，只需将 Plugin ‘插件地址’ 删除或者注释掉，再进入 vim 执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:PluginClean</div></pre></td></tr></table></figure>
<p>便将插件删除。</p>
<p>如需升级插件，进入 vim 执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:PluginUpdate</div></pre></td></tr></table></figure></p>
<p>便完成升级。</p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[本地挂载服务器文件夹工具---「sshfs」的安装及使用]]></title>
      <url>/2017/08/03/sshfs-install-and-using-on-mac/</url>
      <content type="html"><![CDATA[<p>对于习惯在本地使用「<strong>IDE</strong>」工具进行编辑而不习惯在服务器上使用 「<strong>vim</strong>」 进行编辑的同学，下面介绍一个非常方便的在本地挂载服务器文件夹的工具 「<strong>sshfs</strong>」。下面介绍在「<strong>Mac</strong>」(系统版本：macOS Sierra 10.12.6)下的安装及使用方法：</p>
<h1 id="安装「sshfs」"><a href="#安装「sshfs」" class="headerlink" title="安装「sshfs」"></a>安装「<strong>sshfs</strong>」</h1><h2 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 <a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew</a></h2><a id="more"></a>
<p>先确定是否已经安装「<strong>Homebrew</strong>」，在命令行执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew -v</div></pre></td></tr></table></figure></p>
<p>输出示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Homebrew &gt;1.2.0 (no git repository)</div><div class="line">Homebrew/homebrew-core (git revision 9cf7; last commit 2017-09-22)</div></pre></td></tr></table></figure></p>
<p>如果没有安装，则执行如下命令进行安装，在命令行执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure></p>
<h2 id="安装-「sshfs」-的依赖-「osxfuse」"><a href="#安装-「sshfs」-的依赖-「osxfuse」" class="headerlink" title="安装 「sshfs」 的依赖 「osxfuse」"></a>安装 「<strong>sshfs</strong>」 的依赖 「<strong>osxfuse</strong>」</h2><p>执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install caskroom/cask/osxfuse</div></pre></td></tr></table></figure></p>
<h2 id="安装-「sshfs」"><a href="#安装-「sshfs」" class="headerlink" title="安装 「sshfs」"></a>安装 「<strong>sshfs</strong>」</h2><p>执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install sshfs</div></pre></td></tr></table></figure></p>
<h1 id="使用-「sshfs」-挂载"><a href="#使用-「sshfs」-挂载" class="headerlink" title="使用 「sshfs」 挂载"></a>使用 「<strong>sshfs</strong>」 挂载</h1><p>执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sshfs -C -o reconnect user@hostname:remote_dir local_dir</div></pre></td></tr></table></figure></p>
<p>参数说明如下：</p>
<ul>
<li>user: 远程连接用户名</li>
<li>hostname: 远程连接的主机名</li>
<li>remote_dir: 远程目录</li>
<li>local_dir: 本地目录</li>
</ul>
<h1 id="查看挂载情况"><a href="#查看挂载情况" class="headerlink" title="查看挂载情况"></a>查看挂载情况</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df -h local_dir</div></pre></td></tr></table></figure>
<h1 id="使用-「umount」-取消挂载"><a href="#使用-「umount」-取消挂载" class="headerlink" title="使用 「umount」 取消挂载"></a>使用 「<strong>umount</strong>」 取消挂载</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">umount local_dir</div></pre></td></tr></table></figure>
<h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><p>如过我们的Mac休眠或重启, 发现挂载的失败了, 进入目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls local_dir</div></pre></td></tr></table></figure></p>
<p>会提示如下类似信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls: local_dir: Input/output error</div></pre></td></tr></table></figure></p>
<p>取消挂载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">umount local_dir</div></pre></td></tr></table></figure></p>
<p>又会提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">umount: local_dir: not currently mounted</div></pre></td></tr></table></figure></p>
<p>这个时候, 我们不得不关闭进程了, 可以先通过命令查看进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pgrep -lf sshfs</div></pre></td></tr></table></figure></p>
<p>然后杀掉相应的挂载进程, 或者直接杀掉所有挂载进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pkill -9 sshfs</div></pre></td></tr></table></figure></p>
<p>之后重新挂载响应的目录即可</p>
<p>相关链接：<a href="http://www.jianshu.com/p/8723ba79f35a" target="_blank" rel="external">http://www.jianshu.com/p/8723ba79f35a</a></p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sshfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown 使用教程]]></title>
      <url>/2017/08/02/markdown-using-tutorial/</url>
      <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">不同数量的# 标题内容</div></pre></td></tr></table></figure></p>
<p>说明：在Markdown中，标题共计六个等级，标题字号随等级的升高而相应的降低。<br><a id="more"></a></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 一级标题</div><div class="line">## 二级标题</div><div class="line">### 三级标题</div><div class="line">#### 四级标题</div><div class="line">#####  五级标题</div><div class="line">######  六级标题</div></pre></td></tr></table></figure>
<p>示例显示效果：</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote>
<h1 id="斜体、粗体、加粗斜体、删除线"><a href="#斜体、粗体、加粗斜体、删除线" class="headerlink" title="斜体、粗体、加粗斜体、删除线"></a>斜体、粗体、加粗斜体、删除线</h1><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*斜体*</div><div class="line">**粗体**</div><div class="line">***加粗斜体***</div><div class="line">~~删除线~~</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p><em>斜体</em><br><strong>粗体</strong><br><strong><em>加粗斜体</em></strong><br><del>删除线</del></p>
</blockquote>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;链接地址&gt;</div></pre></td></tr></table></figure></p>
<p>说明：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，Markdown 就会自动把它转成链接。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;https://chengjinli.github.io/&gt;</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p><a href="https://chengjinli.github.io/" target="_blank" rel="external">https://chengjinli.github.io/</a></p>
</blockquote>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[链接文字](链接地址 &quot;链接标题&quot;)</div></pre></td></tr></table></figure></p>
<p>说明：()中的””之间可以为链接指定title，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title 文字。链接地址与链接标题前有一个空格。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[MJ&apos;s Learning Notes](https://chengjinli.github.io/)</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p><a href="https://chengjinli.github.io/" target="_blank" rel="external">MJ’s Learning Notes</a></p>
</blockquote>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">数字加一个英文句点</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. 有序列表1</div><div class="line">2. 有序列表2</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<ol>
<li>有序列表1</li>
<li>有序列表2</li>
</ol>
</blockquote>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*，+，- 加上列表内容</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">* 无序列表1</div><div class="line">* 无序列表2</div><div class="line">+ 无序列表3</div><div class="line">+ 无序列表4</div><div class="line">- 无序列表5</div><div class="line">- 无序列表6</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<ul>
<li>无序列表1</li>
<li>无序列表2</li>
</ul>
<ul>
<li>无序列表3</li>
<li>无序列表4</li>
</ul>
<ul>
<li>无序列表5</li>
<li>无序列表6</li>
</ul>
</blockquote>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="单层引用"><a href="#单层引用" class="headerlink" title="单层引用"></a>单层引用</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;加上被引用的内容</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; 一行内容的引用</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p>一行内容的引用</p>
</blockquote>
<h2 id="多层引用"><a href="#多层引用" class="headerlink" title="多层引用"></a>多层引用</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">不同数量的&gt;加上被引用的内容</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;第3层引用</div><div class="line"></div><div class="line">&gt;&gt;第2层引用</div><div class="line"></div><div class="line">&gt;第1层引用</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<blockquote>
<blockquote>
<p>第3层引用</p>
</blockquote>
<p>第2层引用</p>
</blockquote>
<p>第1层引用</p>
</blockquote>
<h2 id="引用其他元素"><a href="#引用其他元素" class="headerlink" title="引用其他元素"></a>引用其他元素</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; ### 三级标题</div><div class="line">&gt; 1. 第一行列表内容</div><div class="line">&gt; 2. 第二行列表内容</div><div class="line">&gt; </div><div class="line">&gt; 插入代码的例子</div><div class="line">&gt; `print (&quot;MJ&quot;)`</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<h3 id="三级标题-1"><a href="#三级标题-1" class="headerlink" title="三级标题"></a>三级标题</h3><ol>
<li>第一行列表内容</li>
<li>第二行列表内容</li>
</ol>
<p><code>print (&quot;MJ&quot;)</code></p>
</blockquote>
<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![图片Alt](图片地址 &quot;图片Title&quot;)</div></pre></td></tr></table></figure></p>
<p>说明：[]中写图片Alt，如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。()里写图片地址，()图片Title表示鼠标悬停在图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![头像](https://chengjinli.github.io/images/MJ.jpg &quot;MJ&quot;)</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p><img src="https://chengjinli.github.io/images/MJ.jpg" alt="头像" title="MJ"></p>
</blockquote>
<h1 id="LaTeX公式"><a href="#LaTeX公式" class="headerlink" title="LaTeX公式"></a>LaTeX公式</h1><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$公式$</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>
</blockquote>
<h2 id="正行公式"><a href="#正行公式" class="headerlink" title="正行公式"></a>正行公式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$公式$$</div></pre></td></tr></table></figure>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$$\sum_&#123;i=1&#125;^n a_i=0$$</div><div class="line">$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</div><div class="line">$$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$$</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p>$$\sum_{i=1}^n a_i=0$$</p>
<p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2$$</p>
</blockquote>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>语法说明：</p>
<ol>
<li>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。</li>
<li>列于列之间用管道符“|”隔开。原生方式的表格每一行的两边也要有管道符。</li>
<li>第二行还可以为不同的列指定对齐方向。默认为左对齐，在 “-” 右边加上 “:” 为右对齐，在 “-” 两侧同时加上 “:” 为居中对齐。</li>
</ol>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">|年|月|日|</div><div class="line">|-|:-:|-:|</div><div class="line">|2015|5|5|</div><div class="line">|2016|6|6|</div><div class="line">|2017|7|7|</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<table>
<thead>
<tr>
<th>年</th>
<th style="text-align:center">月</th>
<th style="text-align:right">日</th>
</tr>
</thead>
<tbody>
<tr>
<td>2015</td>
<td style="text-align:center">5</td>
<td style="text-align:right">5</td>
</tr>
<tr>
<td>2016</td>
<td style="text-align:center">6</td>
<td style="text-align:right">6</td>
</tr>
<tr>
<td>2017</td>
<td style="text-align:center">7</td>
<td style="text-align:right">7</td>
</tr>
</tbody>
</table>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>语法：<br>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* * *</div><div class="line">***</div><div class="line">*****</div><div class="line">- - -</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<hr>
<hr>
<hr>
<hr>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`代码`</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python语言里的函数`print()`怎么使用？</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p>python语言里的函数<code>print()</code>怎么使用？</p>
</blockquote>
<h2 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h2><p>语法：<br>```<br>第1行代码<br>第2行代码<br>```</p>
<p>示例：<br>```python<br>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    print(“MJ”)<br>```</p>
<p>示例显示效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    print(<span class="string">"MJ"</span>)</div></pre></td></tr></table></figure></p>
<h2 id="缩进式代码"><a href="#缩进式代码" class="headerlink" title="缩进式代码"></a>缩进式代码</h2><p>语法：<br>缩进 4 个空格或是 1 个制表符，一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    print(<span class="string">"MJ"</span>)</div></pre></td></tr></table></figure></p>
<p>示例显示效果:</p>
<pre><code>if __name__ == &apos;__main__&apos;:
    print(&quot;MJ&quot;)
</code></pre><h1 id="相关链接："><a href="#相关链接：" class="headerlink" title="相关链接："></a>相关链接：</h1><p><a href="http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-6" target="_blank" rel="external">http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-6</a></p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Hexo + Next + github/coding 搭建个人静态博客]]></title>
      <url>/2017/08/01/use-hexo-next-github-and-coding-build-static-blog/</url>
      <content type="html"><![CDATA[<p>博客框架使用 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo</a><br>主题使用 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">NexT</a><br>代码托管使用 <a href="https://mart.coding.net/" target="_blank" rel="external">Coding</a><br><a id="more"></a></p>
<h1 id="Next主题修改文章内链接文本样式"><a href="#Next主题修改文章内链接文本样式" class="headerlink" title="Next主题修改文章内链接文本样式"></a>Next主题修改文章内链接文本样式</h1><p>实现效果：<br><a href="https://chengjin.li/" target="_blank" rel="external">https://chengjin.li/</a></p>
<p>在<code>themes\next\source\css\_common\components\post\post.styl</code>文件如下位置添加css样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.post-sticky-flag &#123;</div><div class="line">  display: inline-block;</div><div class="line">  font-size: 16px;</div><div class="line">  -ms-transform: rotate(30deg);</div><div class="line">  transform: rotate(30deg);</div><div class="line">&#125;</div><div class="line">// 文章内链接文本样式</div><div class="line">.post-body p a&#123;</div><div class="line">  color: #0593d3;</div><div class="line">  border-bottom: none;</div><div class="line">  &amp;:hover &#123;</div><div class="line">    color: #fc6423;</div><div class="line">    border-bottom: none;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Next主题添加鼠标心形点击特效"><a href="#Next主题添加鼠标心形点击特效" class="headerlink" title="Next主题添加鼠标心形点击特效"></a>Next主题添加鼠标心形点击特效</h1><p>1、 在<code>themes\next\source\js\src\</code>目录下新建<code>love.js</code>,代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</div></pre></td></tr></table></figure></p>
<p>2、 在<code>themes\next\layout\_layout.swig</code>文件的最下方，<code>&lt;/body&gt;</code>前面添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h1 id="Next主题修改文章底部的那个带-号的标签"><a href="#Next主题修改文章底部的那个带-号的标签" class="headerlink" title="Next主题修改文章底部的那个带#号的标签"></a>Next主题修改文章底部的那个带#号的标签</h1><p>实现效果：<br><img src="/images/label_modified_impression_drawing.png" alt="标签修改后的效果图"></p>
<p>方法：<br>修改模板<code>themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成 <code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h1 id="Next主题在每篇文章末尾统一添加“本文结束”标记"><a href="#Next主题在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="Next主题在每篇文章末尾统一添加“本文结束”标记"></a>Next主题在每篇文章末尾统一添加“本文结束”标记</h1><p>实现效果：<br><img src="/images/end_of_text.png" alt="本文结束标记"><br>方法：</p>
<p>在路径<code>themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件，并添加以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">    &#123;% if not is_index %&#125;</div><div class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</div><div class="line">    &#123;% endif %&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>接着打开<code>themes\next\layout\_macro\post.swig</code>文件，在 <code>post-body</code> 之后， <code>post-footer</code> 之前添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &#123;% if not is_index %&#125;</div><div class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</div><div class="line">  &#123;% endif %&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>然后打开主题配置文件<code>_config.yml</code>，在末尾添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 文章末尾添加“本文结束”标记</div><div class="line">passage_end_tag:</div><div class="line">  enabled: true</div></pre></td></tr></table></figure></p>
<h1 id="Next主题修改作者头像并旋转"><a href="#Next主题修改作者头像并旋转" class="headerlink" title="Next主题修改作者头像并旋转"></a>Next主题修改作者头像并旋转</h1><p>打开<code>themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code>，修改<code>site-author-image</code>相代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">.site-author-image &#123;</div><div class="line">  display: block;</div><div class="line">  margin: 0 auto;</div><div class="line">  padding: $site-author-image-padding;</div><div class="line">  max-width: $site-author-image-width;</div><div class="line">  height: $site-author-image-height;</div><div class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</div><div class="line"></div><div class="line">  /* 头像圆形 */</div><div class="line">  border-radius: 70px;</div><div class="line">  -webkit-border-radius: 70px;</div><div class="line">  -moz-border-radius: 70px;</div><div class="line">  box-shadow: inset 0 -1px 0 #333sf;</div><div class="line"></div><div class="line">  /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 </div><div class="line">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</div><div class="line"></div><div class="line"></div><div class="line">  /* 鼠标经过头像旋转360度 */</div><div class="line">  -webkit-transition: -webkit-transform 1.0s ease-out;</div><div class="line">  -moz-transition: -moz-transform 1.0s ease-out;</div><div class="line">  transition: transform 1.0s ease-out;</div><div class="line">&#125;</div><div class="line"></div><div class="line">img:hover &#123;</div><div class="line">  /* 鼠标经过停止头像旋转 </div><div class="line">  -webkit-animation-play-state:paused;</div><div class="line">  animation-play-state:paused;*/</div><div class="line"></div><div class="line">  /* 鼠标经过头像旋转360度 */</div><div class="line">  -webkit-transform: rotateZ(360deg);</div><div class="line">  -moz-transform: rotateZ(360deg);</div><div class="line">  transform: rotateZ(360deg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Z 轴旋转动画 */</div><div class="line">@-webkit-keyframes play &#123;</div><div class="line">  0% &#123;</div><div class="line">    -webkit-transform: rotateZ(0deg);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    -webkit-transform: rotateZ(-360deg);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">@-moz-keyframes play &#123;</div><div class="line">  0% &#123;</div><div class="line">    -moz-transform: rotateZ(0deg);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    -moz-transform: rotateZ(-360deg);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">@keyframes play &#123;</div><div class="line">  0% &#123;</div><div class="line">    transform: rotateZ(0deg);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    transform: rotateZ(-360deg);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Next主题设置网站的图标Favicon"><a href="#Next主题设置网站的图标Favicon" class="headerlink" title="Next主题设置网站的图标Favicon"></a>Next主题设置网站的图标Favicon</h1><p>方法：<br>将一张32x32的ico图标名称改为favicon.ico，然后把图标放在<code>themes/next/source/images</code>里，并且修改主题配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Put your favicon.ico into `hexo-site/source/` directory.</div><div class="line">favicon: /images/favicon.ico</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
