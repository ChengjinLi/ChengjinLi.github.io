<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[XGBoost 参数说明]]></title>
      <url>/2018/08/05/xgboost-parameter-description/</url>
      <content type="html"><![CDATA[<h1 id="XGBoost-参数"><a href="#XGBoost-参数" class="headerlink" title="XGBoost 参数"></a>XGBoost 参数</h1><p><a href="https://xgboost.readthedocs.io/en/latest//parameter.html" target="_blank" rel="external">XGBoost 官方参数说明文档</a>，XGBoost 版本：0.72。</p>
<p>在运行 XGBoost 之前，必须设置三种类型参数：通用参数(General Parameters)、提升参数(Booster Parameters)和任务参数(Task Parameters)。<br><a id="more"></a></p>
<ul>
<li>通用参数(General Parameters)：设置整体功能，参数控制在提升(boosting)过程中使用哪种booster，常用的booster有树模型(tree model)和线性模型(linear model)。</li>
<li>提升参数(Booster Parameters)：这取决于使用哪种booster(树or回归)。</li>
<li>任务参数(Task Parameters)：控制学习的场景，例如在回归问题中会使用不同的参数控制排序。</li>
</ul>
<h2 id="通用参数-General-Parameters"><a href="#通用参数-General-Parameters" class="headerlink" title="通用参数(General Parameters)"></a>通用参数(General Parameters)</h2><p>下面这些参数定义了 XGBoost 的总体功能：</p>
<ul>
<li><p>booster [default=gbtree]</p>
<ul>
<li>选择每次迭代过程中需要运行的模型，一共有两种模型可以选择：</li>
<li>gbtree：使用基于树的模型进行提升计算；</li>
<li>gblinear：使用线性模型进行提升计算；</li>
</ul>
</li>
<li><p>silent [default=0]</p>
<ul>
<li>设置模型是否打印运行时信息：</li>
<li>0：打印出运行时信息 </li>
<li>1：不打印出运行时信息</li>
</ul>
</li>
<li><p>nthread [default=可用的最大线程数] </p>
<ul>
<li>XGBoost 运行时的线程数，默认值为当前系统可以获得的最大线程数。</li>
</ul>
</li>
<li><p>num_pbuffer [由 XGBoost 自动设置，不需要用户设置]</p>
<ul>
<li>预测缓冲区的大小，通常设置为训练实例的数目。缓冲区用于保存最后一次升压步骤的预测结果。</li>
</ul>
</li>
<li><p>num_feature [由 XGBoost 自动设置，不需要用户设置]</p>
<ul>
<li>boosting 过程中用到的特征维数，设置为特征个数。</li>
</ul>
</li>
</ul>
<h2 id="提升参数-Booster-Parameters"><a href="#提升参数-Booster-Parameters" class="headerlink" title="提升参数(Booster Parameters)"></a>提升参数(Booster Parameters)</h2><h3 id="树模型-Booster-参数"><a href="#树模型-Booster-参数" class="headerlink" title="树模型 Booster 参数"></a>树模型 Booster 参数</h3><ul>
<li><p>eta [default=0.3，别名: learning_rate]</p>
<ul>
<li>为了防止过拟合，更新过程中用到的收缩步长。在每次提升计算之后，算法会直接获得新特征的权重。eta 通过缩减每一步特征的权重使提升计算过程更加保守，使得模型更加健壮。</li>
<li>取值范围：[0，1]。典型值一般设置为：0.01~0.2。</li>
</ul>
</li>
<li><p>gamma [default=0，别名：min_split_loss]</p>
<ul>
<li>在树的叶子节点上进行进一步分割，所需要的最小损失函数减少的大小。越大，算法就越保守。<br>这个值一般来说需要根据损失函数来调整。</li>
<li>取值范围：[0,∞]</li>
</ul>
</li>
<li><p>max_depth [default=6]</p>
<ul>
<li>树的最大深度，值越大，树越复杂。可以用来控制过拟合。</li>
<li>取值范围：[1,∞]。典型值是3-10。</li>
</ul>
</li>
<li><p>min_child_weight [default=1] </p>
<ul>
<li>孩子节点中最小的样本权重(hessian)和。如果一个叶子节点的样本权重和小于min_child_weight，则拆分过程将放弃进一步的划分。在线性回归任务中，这个参数是指建立每个模型所需要的最小样本数。该参数越大算法越保守。这个参数可以用来减少过拟合，但是过高的值也会导致欠拟合，因此可以通过交叉验证来调。</li>
<li>取值范围: [0,∞]</li>
</ul>
</li>
<li><p>max_delta_step [default=0] </p>
<ul>
<li>最大增量步骤，我们允许每个叶子输出。如果该值设置为0，则意味着没有约束。如果它被设置为正值，有助于更新步骤更加保守。通常不需要这个参数，当类是非常不平衡的时，它可能有助于 logistic 回归。将其设置为 1~10 的值可能有助于控制更新。</li>
<li>取值范围：[0,∞]</li>
</ul>
</li>
<li><p>subsample [default=1]</p>
<ul>
<li>用于训练模型的子样本占整个样本集合的比例。如果设置为0.5则意味着 XGBoost 将随机的从整个样本集合中随机的抽取出50%的子样本建立树模型，这能够防止过拟合。</li>
<li>取值范围为：(0,1]</li>
</ul>
</li>
<li><p>colsample_bytree [default=1]</p>
<ul>
<li>在构建每棵树时，列的采样比(一般是特征采样比)。在每次 boosting 迭代中都会出现一次采样。</li>
<li>取值范围：(0,1]</li>
</ul>
</li>
<li><p>colsample_bylevel [default=1]</p>
<ul>
<li>在每个级别上，每个样本的子样本比。每次进行新的分割时，都会出现次采样。<br>当 tree_method 设置为hist时，此参数没有任何影响。这个一般很少用，subsample 和 colsample_bytree 参数调节就足够了。</li>
</ul>
</li>
<li><p>lambda [default=1, 别名: reg_lambda]</p>
<ul>
<li>权重的L2正则化项，增加这个值会使模型更保守。这个其实用的很少。</li>
</ul>
</li>
<li><p>alpha [default=0, 别名: reg_alpha]</p>
<ul>
<li>权重的L1正则化项，增加这个值会使模型更保守。这个主要是用在数据维度很高的情况下，可以提高运行速度。</li>
</ul>
</li>
<li><p>tree_method [default=auto]</p>
<ul>
<li>XGBoost 中使用的树构造算法。参见<a href="https://arxiv.org/abs/1603.02754" target="_blank" rel="external">参考文献</a>中的描述。</li>
<li>分布式和外存版本只支持近似算法(tree_method=approx)。</li>
<li>选项: ‘auto’、’approx’、’exact’、’hist’、’gpu_exact’、’gpu_hist’。<ul>
<li>‘auto’: 用启发式方法去选择最快的一个。<ul>
<li>对于小到中数据集，将使用精确的贪心算法。</li>
<li>对于大数据集，会选择近似算法。</li>
<li>由于之前总是在单台机器上使用精确的贪心算法，所以当选择近似算法时，用户会得到一条消息来通知这个选择。</li>
</ul>
</li>
<li>‘exact’: 使用贪心算法</li>
<li>‘approx’: 使用草图和直方图的近似贪心算法</li>
<li>‘hist’: 快速直方图优化近似贪婪算法。它使用了一些性能改进，比如垃圾箱缓存。</li>
<li>‘gpu_exact’: 使用gpu执行exact算法</li>
<li>‘gpu_hist’: 使用gpu执行hist算法</li>
</ul>
</li>
</ul>
</li>
<li><p>sketch_eps [default=0.03] </p>
<ul>
<li>这个选项适用于近似贪心算法。</li>
<li>这大概可以理解为O(1/sketcheps)数量的箱子。与直接选择的箱数相比，该方法具有一定的理论保证和梗概精度。</li>
<li>通常用户不需要调整这个参数，但是使用一个较低的值唯一获得更多的精确的列举。</li>
<li>取值范围：(0,1)</li>
</ul>
</li>
<li><p>scale_pos_weight [default=1]</p>
<ul>
<li>用于类别不平衡的情况下，控制正负权重的平衡。将参数设置大于0，可以加快收敛。</li>
</ul>
</li>
<li><p>updater [default=grow_colmaker,prune] </p>
<ul>
<li>一个逗号分隔的字符串，定义了要运行的树更新器的序列，提供了一种构造和修改树的模块化方法。这是一个高级的参数通常设置为自动的，取决于其他参数。它也可以被用户明确的定义。有下列的更新器插件: <ul>
<li>‘grow_colmaker’: 非分布的基于列的树结构。</li>
<li>‘discol’: 采用基于列的数据分割模式的分布式树结构。</li>
<li>‘grow_histmaker’: 基于基于直方图计数的全局建议的基于行的数据分割的分布式树结构。</li>
<li>‘grow_local_histmaker’: 基于局部直方图计数。</li>
<li>‘grow_skmaker’: 使用近似的草图算法。</li>
<li>‘refresh’: 根据当前数据刷新树的统计和/或叶值。注意，不执行任何随机的数据行子抽样。</li>
<li>‘prune’: 在损失小于min_split_loss (or gamma)的情况下修剪。</li>
</ul>
</li>
<li>在分布式设置中，updater序列应该调整为’grow_histmaker,prune’</li>
</ul>
</li>
<li><p>refresh_leaf [default=1]</p>
<ul>
<li>设置一个刷新updater插件的参数。当标志为1时，树叶和树节点的统计信息都更新了。当标志为0时，只更新节点属性。</li>
</ul>
</li>
<li><p>process_type [default=default]</p>
<ul>
<li>一种可运行的 boosting 过程</li>
<li>选项: {‘default’，’update’} <ul>
<li>‘default’: 普通的 boosting 过程来创建新的树。</li>
<li>‘update’: 从一个已经存在的模型并且仅仅更新它的树。在每一次 boosting 迭代，从初始模型得到的树，一个指定序列的 updater 插件为这些树运行，修改后的树被添加到新的模型。新的模型可能有相同或者更少的树，取决于 boosting 迭代的次数。目前，以下内置的 updater 插件可以与此过程类型有意义的使用:’refresh’, ‘prune’。如果 process_type=update，你就不能使用 updater 插件来创建新的树。</li>
</ul>
</li>
</ul>
</li>
<li><p>grow_policy [default=depthwise] </p>
<ul>
<li>控制节点被添加到树的方式</li>
<li>目前仅仅支持 tree_method=hist 时的设置。</li>
<li>选项: {‘depthwise’, ‘lossguide’} <ul>
<li>‘depthwise’: 在离根最近的节点处分割</li>
<li>‘lossguide’: 在最大的 loss 改变出分割</li>
</ul>
</li>
</ul>
</li>
<li><p>max_leaves [default=0] </p>
<ul>
<li>最多添加的节点数量。仅当 grow_policy=lossguide 时相关。</li>
</ul>
</li>
<li><p>max_bin [default=256] </p>
<ul>
<li>仅当 tree_method=hist 时有用。</li>
<li>最大的离散箱数，以存储连续的特性。</li>
<li>增加这个数字可以减少计算时间成本。</li>
</ul>
</li>
<li><p>predictor [default=cpu_predictor] </p>
<ul>
<li>选择预测算法的类型。提供同样的结果但是可以选择使用CPU或者GPU。 <ul>
<li>cpu_predictor: 使用多核CPU预测算法。</li>
<li>gpu_predictor: 使用gpu预测。如果 tree_method 设置为 gpu_exact 或者 gpu_hist，那么这个就是默认选项。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Dart-Booster-额外的参数-booster-dart"><a href="#Dart-Booster-额外的参数-booster-dart" class="headerlink" title="Dart Booster 额外的参数(booster=dart)"></a>Dart Booster 额外的参数(booster=dart)</h3><p>Dart Booster 将 dropout 引入模型，这里的 dropout 不是直接扔掉，而是变权值。</p>
<ul>
<li><p>sample_type [default=uniform]</p>
<ul>
<li>算法抽样的类型 <ul>
<li>uniform: 均匀选择树 dropped。</li>
<li>weighted: 按照权重来选择树dropped。</li>
</ul>
</li>
</ul>
</li>
<li><p>normalize_type [default=tree] </p>
<ul>
<li>归一化算法的类型 <ul>
<li>tree: 新的树和每一个 dropped 树有同样的权重。<ul>
<li>新的树的权重为 1 / (k + learning_rate)。</li>
<li>dropped 树乘以一个系数 k / (k + learning_rate)。</li>
</ul>
</li>
<li>forest: 新的树和所有 dropped 树的和有相同的权重。<ul>
<li>新的树的权重为 1 / (1 + learning_rate)。</li>
<li>dropped 树乘以一个系数 1 / (1 + learning_rate)。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>rate_drop [default=0.0]</p>
<ul>
<li>dropout的概率(在生成的树中 dropped 一部分)。</li>
<li>取值范围: [0.0, 1.0]</li>
</ul>
</li>
<li><p>one_drop [default=0]</p>
<ul>
<li>当这个被设置时，至少有一个树始终会被 dropped（支持原始 DART 论文中的 Binomial-plus-one 或 epsilon-dropout）.</li>
</ul>
</li>
<li><p>skip_drop [default=0.0]</p>
<ul>
<li>在 boosting 迭代的过程中略过 dropout 过程的概率。<ul>
<li>如果一次 dropout 被略过，新的树被添加进 model 用和 gbtree 一样的方式。</li>
<li>非0的 skip_drop 比 rate_drop 和 one_drop 有更高的优先级。</li>
</ul>
</li>
<li>取值范围: [0.0, 1.0]</li>
</ul>
</li>
</ul>
<h3 id="线性Booster的参数-booster-gblinear"><a href="#线性Booster的参数-booster-gblinear" class="headerlink" title="线性Booster的参数(booster=gblinear)"></a>线性Booster的参数(booster=gblinear)</h3><ul>
<li><p>lambda [default=0, 别名:reg_lambda]</p>
<ul>
<li>L2正则化的权重，增加该参数的值会让模型更保守</li>
</ul>
</li>
<li><p>alpha [default=0, 别名:reg_alpha]</p>
<ul>
<li>L1正则化的权重，增加这个值会让模型更保守。归一化到训练实例的数量。</li>
</ul>
</li>
</ul>
<ul>
<li>updater [default=shotgun]<ul>
<li>选择算法拟合线性模型<ul>
<li>shotgun: 基于 shotgun 算法的并行坐标下降算法。使用 ‘HOGRAVE’ 并行性，因此在每次运行时产生一个非确定性的解决方案。</li>
<li>coord_descent: 普通坐标下降算法。而且多线程下仍然产生确定性的解决方案。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Tweedie-Regression-的参数-objective-reg-tweedie"><a href="#Tweedie-Regression-的参数-objective-reg-tweedie" class="headerlink" title="Tweedie Regression 的参数(objective=reg:tweedie)"></a>Tweedie Regression 的参数(objective=reg:tweedie)</h3><ul>
<li>tweedie_variance_power [default=1.5]<ul>
<li>在 Tweedie 分布上控制方差的参数 <ul>
<li>var(y)~E(y)^tweedie_variance_power</li>
</ul>
</li>
<li>取值范围: (1,2)</li>
<li>值越接近2越接近 gamma 分布</li>
<li>值越接近1越接近 Poisson 分布</li>
</ul>
</li>
</ul>
<h2 id="学习任务参数-Learning-Task-Parameters"><a href="#学习任务参数-Learning-Task-Parameters" class="headerlink" title="学习任务参数(Learning Task Parameters)"></a>学习任务参数(Learning Task Parameters)</h2><p>指定学习任务和相应的学习目标。下面的目标选项如下:</p>
<ul>
<li><p>objective [default=reg:linear]</p>
<ul>
<li>‘reg:linear’：线性回归。</li>
<li>‘reg:logistic’：逻辑回归。</li>
<li>‘binary:logistic’：二分类的逻辑回归，输出概率。</li>
<li>‘binary:logitraw’：二分类的逻辑回归，在逻辑变换前输出得分。</li>
<li>‘binary:hinge’：二分类的 hinge loss。使得预测结果为0或1，而不是产生概率。</li>
<li>‘gpu:reg:linear, gpu:reg:logistic, gpu:binary:logistic, gpu:binary:logitraw’: 对应在 GPU 上评价的目标函数版本。注意，像 GPU 直方图算法一样，它们只能在整个训练期间使用相同数据集时使用。</li>
<li>‘count:poisson’：用于统计数据的 poisson 回归，输出 poisson 分布均值。<ul>
<li>max_delta_step：在 poisson 回归中默认值设置为0.7(用于维护优化)。</li>
</ul>
</li>
<li>‘survival:cox’：用于正确删除的生存时间数据的 Cox 回归(被正确删除的作为负例)。注意，预测是按危害比表中的值返回。(例如：在比例风险函数h(t) = h0(t) * HR中，HR = exp(marginal_prediction)。</li>
<li>‘multi:softmax’：设置 XGBoost 做多分类任务用 softmax 目标，你需要指定 num_class。</li>
<li>‘multi:softprob’：和 softmax 一样，但是输出的是一个 ndata <em> nclass 的向量，可以进一步变形为 ndata </em> nclass 的矩阵。结果包含预测的每个数据属于每个类的概率值。</li>
<li>‘rank:pairwise’：通过最小化 pairwise loss，设置 XGBoost 用于排序任务。</li>
<li>‘reg:gamma’：用 log-link 的 gamma 回归。输出是 gamma 分布的均值。他是有用的，例如：为了模拟保险索赔的严谨性，或者任何输出结果可能是 gamma 分布的。</li>
<li>‘reg:tweedie’：用 log-link 的 Tweedie 回归。他是有用的，例如：模拟保险全损，或者任何输出结果可能是 Tweedie 分布的。</li>
</ul>
</li>
<li><p>base_score [default=0.5]</p>
<ul>
<li>初始化的所有例子的越策得分，全局 bias</li>
<li>对于足够多的迭代次数，改变这个值不会有太大的效果</li>
</ul>
</li>
<li><p>eval_metric [default according to objective] </p>
<ul>
<li>对于验证集的评测指标，一个默认的指标是根据目标分配的(对于回归任务用rmse，对于分类任务用error，mean average precision for ranking)</li>
<li>用户可以添加多个评测指标，对于python用户，记得将这些指标存入一个参数对的list而不是map，不然后面的指标将会失效。</li>
<li>可选项如下: <ul>
<li>rmse：root mean square error(均方根误差)。</li>
<li>mae：mean absolute error(绝对值误差)。</li>
<li>logloss：negative log-likelihood(负对数似然)。</li>
<li>error：二分类错误率。他可以用公式 #(wrong cases)/#(all cases)计算。对于预测，指标会把预测结果大于0.5的当做正类，其他当做负类。</li>
<li>error@t：与阈值为0.5的二分类不同，可以通过 t 设置阈值。</li>
<li>merror：多分类错误率，可以用公式 #(wrong cases)/#(all cases)计算。</li>
<li>mlogloss：Multiclass logloss(多分类对数似然)。</li>
<li>auc：Area under the curve(曲线下面积)。</li>
<li>ndcg：Normalized Discounted Cumulative Gain(归一化累积获得收益)</li>
<li>map：Mean average precision(平均准确率，排名任务)。</li>
<li>ndcg@n,map@n：n 可以设置为整数，以切断列表中的顶部位置进行评估。</li>
<li>ndcg-,map-,ndcg@n-,map@n-：在XGBoost，NDCG 和 MAP 将评估没有任何正例样本的列表的得分为1。通过在评价度量中添加“-”，XGBoost 将在某些条件下将这些分数评估为0，反复训练。</li>
<li>poisson-nloglik：Poisson 回归的负对数似然。</li>
<li>gamma-nloglik：gamma 回归的负对数似然。</li>
<li>gamma-deviance：gamma 回归中的差残差</li>
<li>tweedie-nloglik：Tweedie 回归的负对数似然(在tweedie_variance_power参数为特定值)。</li>
</ul>
</li>
</ul>
</li>
<li><p>seed [default=0] </p>
<ul>
<li>随机数种子</li>
</ul>
</li>
</ul>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>下列的参数仅仅被用在命令行版本的xgboost中</p>
<ul>
<li><p>use_buffer [default=1]</p>
<ul>
<li>是否创建一个二进制缓冲从输入文本中。这样做通常会加快加载时间。</li>
</ul>
</li>
<li><p>num_round </p>
<ul>
<li>boosting 的轮数</li>
</ul>
</li>
<li><p>data </p>
<ul>
<li>训练集的路径</li>
</ul>
</li>
<li><p>test:data </p>
<ul>
<li>要预测的测试集的路径</li>
</ul>
</li>
<li><p>save_period [default=0] </p>
<ul>
<li>保存模型的周期，设置 save_period=10 表示每10次 boosting 就会保存一次模型，设置为0表示在训练期间不保存任何模型。</li>
</ul>
</li>
<li><p>task [default=train] 选项:train、pred、eval、dump </p>
<ul>
<li>train：用数据训练</li>
<li>pred：预测test:data</li>
<li>eval：设置eval[name]=filename，评估指定的统计数据</li>
<li>dump：将学习到的模型转换为文本形式</li>
</ul>
</li>
<li><p>model_in [default=NULL]</p>
<ul>
<li>输入模型的路径，用于task为test、eval、dump ，如果被明确地指明训练，xgboost会从输入模型继续训练。</li>
</ul>
</li>
<li><p>model_out [default=NULL]</p>
<ul>
<li>在训练结束后输出模型的路径，如果不知名，会输出0003.model，这里的0003是 boosting 的轮数。</li>
</ul>
</li>
<li><p>model_dir [default=models/]</p>
<ul>
<li>用保存训练期间的模型输出的目录。</li>
</ul>
</li>
<li><p>fmap </p>
<ul>
<li>特征图，用于转换模型。</li>
</ul>
</li>
<li><p>name_dump [default=dump.txt] </p>
<ul>
<li>模型转储文件的名称。</li>
</ul>
</li>
<li><p>name_pred [default=pred.txt] </p>
<ul>
<li>预测文件的名字，用于预测模式。</li>
</ul>
</li>
<li><p>pred_margin [default=0] </p>
<ul>
<li>预测 margin 而不是转换概率。</li>
</ul>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[XGBoost使用教程]]></title>
      <url>/2018/08/04/xgboost-using-tutorial/</url>
      <content type="html"><![CDATA[<p><a href="http://xgboost.readthedocs.io/en/latest/" target="_blank" rel="external">XGBoost官方文档</a><br><a id="more"></a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[product_quantization_tutorial]]></title>
      <url>/2018/05/28/product-quantization-tutorial/</url>
      <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[faiss_install_tutorial]]></title>
      <url>/2018/05/28/faiss-install-tutorial/</url>
      <content type="html"><![CDATA[<p>macOS Sierra (10.12.3)编译Faiss<br>最近Facebook AI实验室开源了相似性搜索库Faiss。<br>Faiss是用于有效的相似性搜索（similarity search）和稠密矢量聚类（clustering of dense vectors）的库。它包含了可在任何大小向量集合里进行搜索的算法，向量集合的大小甚至可达到RAM容纳不下的地步。另外，它还包含了用于评估和参数调优的支持代码。Faiss用C++编写，有Python/numpy的完整包装。其中最有用的一些算法则在GPU上实现。<br><a id="more"></a><br>机器上没有安装HomeBrew的，请参考让Mac也能拥有apt-get类似的功能——Brew。</p>
<p>下面，我们介绍一下如何在macOS Sierra (10.12.3)上编译Faiss。</p>
<p>1.下载Faiss源代码</p>
<p>Shell</p>
<p>$ git clone <a href="https://github.com/facebookresearch/faiss.git" target="_blank" rel="external">https://github.com/facebookresearch/faiss.git</a><br>1<br>$ git clone <a href="https://github.com/facebookresearch/faiss.git" target="_blank" rel="external">https://github.com/facebookresearch/faiss.git</a><br>2.安装编译需要的工具</p>
<p>Shell</p>
<p>$ brew install llvm<br>1<br>$ brew install llvm<br>3.修改调整源代码，准备编译</p>
<p>Shell</p>
<p>$ cd faiss<br>$ cp example_makefiles/makefile.inc.Mac.brew makefile.inc<br>1<br>2<br>$ cd faiss<br>$ cp example_makefiles/makefile.inc.Mac.brew makefile.inc<br>4.编译</p>
<p>Shell</p>
<p>$ make all<br>1<br>$ make all<br>5.执行测试用例</p>
<p>Shell</p>
<p>#需要手工指定动态库的搜索路径，否则会提示“dyld: Library not loaded: @rpath/libomp.dylib”，导致进程无法启动</p>
<p>$ export DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH:/usr/local/opt/llvm/lib/<br>$ ./tests/demo_ivfpq_indexing<br>1<br>2<br>3<br>4</p>
<p>#需要手工指定动态库的搜索路径，否则会提示“dyld: Library not loaded: @rpath/libomp.dylib”，导致进程无法启动</p>
<p>$ export DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH:/usr/local/opt/llvm/lib/<br>$ ./tests/demo_ivfpq_indexing<br>其余的示例，参考源代码中的INSTALL文件中的内容即可。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[序列标注中的几种标签方案]]></title>
      <url>/2017/12/02/sequence-label-Label-scheme/</url>
      <content type="html"><![CDATA[<p>标签说明<br>标签方案中通常都使用一些简短的英文字符[串]来编码。</p>
<p>标签是打在token上的。</p>
<p>对于英文，token可以是一个单词（e.g. awesome），也可以是一个字符（e.g. a）。</p>
<p>对于中文，token可以是一个词语（分词后的结果），也可以是单个汉字字符。</p>
<p>为便于说明，以下都将token试作等同于字符。<br><a id="more"></a><br>标签列表如下：</p>
<p>B，即Begin，表示开始<br>I，即Intermediate，表示中间<br>E，即End，表示结尾<br>S，即Single，表示单个字符<br>O，即Other，表示其他，用于标记无关字符<br>常见标签方案<br>基于上面的标签列表，通过选择该列表的子集，可以得到不同的标签方案。同样的标签列表，不同的使用方法，也可以得到不同的标签方案。</p>
<p>分词、词性标注任务常用的序列表示法有IOB/BIO和start/end。<br>IOB表示法可以分为IOB1，IOB2，IOE1，IOE2四种。四种表示法大同小异，相同点是「I」代表当前词在一个组块中，「O」表示当前的词不在任意一个组块中。不同点是四种表示法对组块的开始或者结束的表达方式所有区别。具体如下：<br>IOB1: 标签I用于文本块中的字符，标签O用于文本块之外的字符，标签B用于当前词是紧跟前一个组块的新组块的开始。非紧邻的新组块开始标记位I。<br>例如：<br>序 I<br>列 I<br>标 B<br>注 I<br>中 O<br>的 O<br>几 O<br>种 O<br>标 I<br>签 I<br>方 B<br>案 I<br>IOB2: 每个文本块都以标签B开始，除此之外，跟IOB1一样。<br>例如：<br>序 B<br>列 I<br>标 B<br>注 I<br>中 O<br>的 O<br>几 O<br>种 O<br>标 B<br>签 I<br>方 B<br>案 I<br>IOE1: 标签I用于独立文本块中，标签E仅用于同类型文本块连续的情况，假如有两个同类型的文本块，那么标签E会被打在第一个文本块的最后一个字符。<br>例如：<br>序 I<br>列 E<br>标 I<br>注 I<br>中 O<br>的 O<br>几 O<br>种 O<br>标 I<br>签 E<br>方 I<br>案 I<br>IOE2: 每个文本块都以标签E结尾，无论该文本块有多少个字符，除此之外，跟IOE1一样。<br>例如：<br>序 I<br>列 E<br>标 I<br>注 E<br>中 O<br>的 O<br>几 O<br>种 O<br>标 I<br>签 E<br>方 I<br>案 E<br>start/end （也叫SBEIO、IOBES）: 是另一个类型的表示法，该表示法表达的更为细致，包含了全部的5种标签，文本块由单个字符组成的时候，使用S标签来表示，由一个以上的字符组成时，首字符总是使用B标签，尾字符总是使用E标签，中间的字符使用I标签。<br>例如：<br>广 B<br>东 I<br>省 E<br>的 O<br>别 B<br>称 E<br>粤 S<br>其中最常用的是IOB2、IOBS、IOBES。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[词向量工具---wordrank使用教程]]></title>
      <url>/2017/11/25/wordrank-tools-using-tutorial/</url>
      <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[词向量工具---fastText简介、使用教程及源码分析]]></title>
      <url>/2017/11/18/fasttext-source-code-analysis/</url>
      <content type="html"><![CDATA[<p>首先我们还是看一下fasttext的目录。所有的C++代码都在src中。然后就是一些linux脚本文件</p>
<p>我们进入src目录看看有哪些C++文件。从上往下看，<br>args是专门存储超参的类。<br>dictionary是词典类，构建存储词典，支持把单词转成id。<br>fasttext是训练测试等的核心文件，会调用model进行词向量文本向量的训练。<br>main是主函数负责接受超参转成args类，根据不同目的调用不同的方法。<br>剩下的matrix，vector等文件都是辅助fasttext，model以及dictionary词典的。</p>
<p>fasttext中文本向量就是词向量的平均，得到文本向量并进行分类的代码和word2vec中的CBOW非常像。我们先看一下classification-example.sh。这个脚本文件会对来自于dbpedia的文本进行分类。分类前要对文本进行预处理并且打乱。</p>
<a id="more"></a>
<h1 id="参数方面"><a href="#参数方面" class="headerlink" title="参数方面"></a>参数方面</h1><ul>
<li>loss function选用hs（hierarchical softmax）要比ns(negative sampling) 训练速度要快很多倍，并且准确率也更高。</li>
<li>wordNgrams 默认为1，设置为2以上可以明显提高准确率。</li>
<li>如果词数不是很多，可以把bucket设置的小一点，否则预留会预留太多bucket使模型太大。</li>
</ul>
<p>因为facebook提供的只是C++版本的代码，上github已经有封装的python接口。用起来特别方便，觉得还不能满足自己的使用要求，修改源码也非常方便。<br>所以对于文本分类，先用fasttext做一个简单的baseline是很适合的。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><img src="/images/fasttext/fasttext-arch.png" alt="fastText的代码结构以及各模块的功能图"></p>
<h1 id="训练数据格式"><a href="#训练数据格式" class="headerlink" title="训练数据格式"></a>训练数据格式</h1><p>训练数据格式为一行一个句子，每个词用空格分割，如果一个词带有前缀 <strong>label</strong>，那么它就作为一个类标签，在文本分类时使用，这个前缀可以通过-label参数自定义。训练文件支持 UTF-8 格式。</p>
<h1 id="fasttext-模块"><a href="#fasttext-模块" class="headerlink" title="fasttext 模块"></a>fasttext 模块</h1><p>fasttext 是最顶层的模块，它的主要功能是训练和预测，首先是训练功能的调用路径，第一个函数是 train，它的主要作用是 初始化参数，启动多线程训练。</p>
]]></content>
      
        <categories>
            
            <category> WordEmbedding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fastText </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[词向量工具---fastText简介、使用教程及源码分析]]></title>
      <url>/2017/11/18/fasttext-tools-using-tutorial/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong><code>fastText</code></strong> 是 <strong><code>Facebook 2016</code></strong> 年开源的一个词向量计算以及文本分类的工具，word2vec 的作者 mikolov 也参与了制作，目前已经引起了广泛的关注。这个工具包的 <a href="https://github.com/facebookresearch/fastText" target="_blank" rel="external">GitHub链接</a>，该项目是 C++ 写的，和之前的项目相比这个项目更加专业，涉及的内容也比之前的项目多很多。在学术上没有什么创新点，但是好处就是模型简单，性能比肩深度学习而且速度更快，用起来很顺手，做出来的结果也可以达到上线使用的标准。该工具其实是由两部分组成，一部分是高效文本分类，一部分是词向量学习。该工具的理论基础是以下两篇论文：</p>
<blockquote>
<p><a href="https://arxiv.org/pdf/1607.01759.pdf" target="_blank" rel="external">Bag of Tricks for Efficient Text Classification</a><br><a id="more"></a></p>
</blockquote>
<p>这篇论文提出了 fastText 算法，介绍高效文本分类技巧，该算法实际上是将目前用来算 word2vec 的 CBOW 模型架构做了个小修改，原先使用一个词的上下文的所有词向量之和来预测词本身，现在改为用一段短文本的词向量之和来对文本进行分类。在生成文本向量的时候用到了ngram的信息，用这个文档所有单词的词向量的平均预测标签。对这种简单的任务，用简单的模型效果就不错了。具体方法就是把句子每个 word 的 vector 求平均，然后直接用简单的LR分类就行。fastText 的 fast 指的是这个。 这个 <a href="https://www.zhihu.com/question/48345431/answer/111513229" target="_blank" rel="external">知乎答案</a> 总结得挺好的，取平均其实算 Deep Learning 的 average pooling。</p>
<p> <img src="/images/fasttext/architecture" alt="fastText文本分类架构图"></p>
<blockquote>
<p><a href="https://arxiv.org/pdf/1607.04606.pdf" target="_blank" rel="external">Enriching Word Vectors with Subword Information</a></p>
</blockquote>
<p>这篇论文使用 subword 信息，也就是连续的字符信息来丰富词汇向量，提出了用 subword 的向量之和来代替简单的词向量的方法，从而使得词的微变形关系也能映射到嵌入空间中，以解决简单 word2vec 无法处理同一词的不同形态的问题。每个词被看做是 n-gram 字母串包。为了区分前后缀情况，”&lt;”， “&gt;” 符号被加到了词的前后端。除了词的子串外，词本身也被包含进了 n-gram 字母串包。以  where 为例，n=3 的情况下，其子串分别为<br>&lt;wh, whe, her, ere, re>，以及其本身 &lt;where><br>注意，这里的 her 与单词 &lt; her> 是不同的。fastText 中提供了 maxn 这个参数来确定 subword 的大小。词向量学习部分可说是一个 word2vec 优化版，用了 subword 的信息，速度是不会提升的，只是效果方面的改进。这个改进能提升模型对 morphology 的效果, 即”字面上”相似的词语 distance 也会小一些. 有人在question-words 数据集上跑过 fastText 和 gensim-word2vec 的对比, 结果在 Jupyter Notebook Viewer .可以看出fastText在 “adjective-to-adverb”, “opposite”之类的数据集上效果还是相当好的. 不过像 “family” 这样的字面上不一样的数据集, fastText效果反而不如 gensim-word2vec.推广到中文上, 结果也类似. “字面上”相似对 vector 的影响非常大. 一个简单的例子是, gensim 训练的模型中与”交易”最相似的是”买卖”, 而 fastText 的结果是”交易法”注：在代码实现中，对于中文是不计算 subword 的。</p>
<h1 id="fastText-用于文本分类"><a href="#fastText-用于文本分类" class="headerlink" title="fastText 用于文本分类"></a>fastText 用于文本分类</h1><p>fastText文本分类模型 = word2vec 中 CBOW 模型 + h-softmax 的灵活使用。<br>模型输入一个词的序列（一段文本或者一句话)，输出这个词序列属于不同类别的概率。<br>序列中的词和词组组成特征向量，特征向量通过线性变换映射到中间层，中间层再映射到标签。fastText 在预测标签时使用了非线性激活函数，但在中间层不使用非线性激活函数。对于有大量类别的数据集，fastText 使用了一个分层分类器（而非扁平式架构）。不同的类别被整合进树形结构中（想象下二叉树而非 列表）。在某些文本分类任务中类别很多，计算线性分类器的复杂度高。为了减少了训练复杂性和测试文本分类器的时间，fastText 利用了类别（class）不均衡这个事实（一些类别出现次数比其他的更多），使用层次 Softmax 技巧。层次 Softmax 通过使用 Huffman 算法建立用于表征类别的树形结构，对标签进行编码，频繁出现的类别的深度要比不频繁出现类别的深度要小，这也使得进一步的计算效率更高。fastText 能在五分钟内将50万个句子分成超过30万个类别。</p>
<blockquote>
<p>注：</p>
<ol>
<li>fastText 只能做多类别分类，从多个类别里预测出一个类。</li>
<li>文本分类单层网络就够了，非线性的问题用多层的。fasttext只有1层神经网络，属于所谓的 shallow learning，比deep learning 模型的优点是训练和预测速度极快，但是 fasttext 的效果并不差，在工业界这点非常重要。</li>
</ol>
</blockquote>
<h1 id="fastText-用于词向量表征"><a href="#fastText-用于词向量表征" class="headerlink" title="fastText 用于词向量表征"></a>fastText 用于词向量表征</h1><p>在 fastText 中一个低维度向量与每个单词都相关。隐藏表征在不同类别所有分类器中进行共享，使得文本信息在不同类别中能够共同使用。常用的特征是词袋模型( Bag-of-Words )，但词袋模型忽略了词序信息，因此 fastText 还加入了 n-gram ，n-gram 来将局部词序考虑在内，特征这对很多文本分类问题来说十分重要。<br>“我 爱 你” 这句话中的词袋模型特征是 “我”，“爱”, “你”。这些特征和句子 “你 爱 我” 的特征是一样的。如果加入 2-gram，第一句话的特征还有 “我-爱” 和 “爱-你”，这两句话 “我 爱 你” 和 “你 爱 我” 就能区别开来了。当然，为了提高效率，我们需要过滤掉低频的 n-gram。</p>
<p>举例来说：fastText 能够学会“男孩”、“女孩”、“男人”、“女人”指代的是特定的性别，并且能够将这些数值存在相关文档中。然后，当某个程序在提出一个用户请求（假设是“我女友现在在儿？”），它能够马上在 fastText 生成的文档中进行查找并且理解用户想要问的是有关女性的问题。 </p>
<blockquote>
<p>facebook 公开了90种语言的 Pre-trained word vectors(词向量维度为300维)，<a href="https://github.com/facebookresearch/fastText/blob/master/pretrained-vectors.md" target="_blank" rel="external">点击了解更多详情</a> 。</p>
</blockquote>
<h1 id="fastText词向量优势"><a href="#fastText词向量优势" class="headerlink" title="fastText词向量优势"></a>fastText词向量优势</h1><ol>
<li>适合大型数据+高效的训练速度：能够训练模型“在使用标准多核CPU的情况下10分钟内处理超过10亿个词汇”，特别是与深度模型对比，fastText 能将训练时间由数天缩短到几秒钟。使用一个标准多核 CPU，得到了在10分钟内训练完超过10亿词汇量模型的结果。此外，fastText 还能在五分钟内将50万个句子分成超过30万个类别。</li>
<li>支持多语言表达：利用其语言形态结构，fastText能够被设计用来支持包括英语、德语、西班牙语、法语以及捷克语等多种语言。它还使用了一种简单高效的纳入子字信息的方式，在用于像捷克语这样词态丰富的语言时，这种方式表现得非常好，这也证明了精心设计的字符 n-gram 特征是丰富词汇表征的重要来源。fastText的性能要比时下流行的word2vec工具明显好上不少，也比其他目前最先进的词态词汇表征要好。 </li>
<li>fastText 专注于文本分类，在许多标准问题上实现当下最好的表现（例如文本倾向性分析或标签预测）。fastText 与基于深度学习方法的 Char-CNN 以及 VDCNN 对比：<br><img src="/images/fasttext/test_accuracy.png" alt="fastText与其他模型的实验结果对比图"> </li>
<li>比word2vec更考虑了同一词的不同形态的问题，比如 fastText 的词向量学习能够考虑 english-born 和 british-born 之间有相同的后缀，但 word2vec 却不能。 </li>
</ol>
<h1 id="fastText-vs-word2vec"><a href="#fastText-vs-word2vec" class="headerlink" title="fastText vs word2vec"></a>fastText vs word2vec</h1><h2 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h2><ol>
<li>图模型结构很像，都是采用 embedding 向量的形式，得到 word 的隐向量表达。</li>
<li>采用很多相似的优化方法，比如使用 Hierarchical softmax 优化训练和预测中的打分速度。</li>
<li>训练词向量时，两者都是无监督算法。输入层是 context window 内的 term。输出层对应的是每一个 term，计算某 term 的概率最大；</li>
<li>在使用层次softmax的时候，huffman 树叶子节点处是训练语料里所有词的向量。</li>
</ol>
<h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><ol>
<li>fastText 用于学习词向量时，加入了词的 subword 信息和 n-gram 信息。 </li>
<li>fastText 用于文本分类时，是有监督算法。输入层对应整个 sentence 的内容，包括term，也包括 n-gram 的内容。输出层对应的是分类的 label。huffmax树叶子节点处是每一个类别标签的词向量</li>
<li>fastText 用于文本分类时，遍历分类树的所有叶节点，找到概率最大的 label（一个或者 N 个）。</li>
</ol>
<h1 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h1><ul>
<li>loss function选用hs（hierarchical softmax）要比ns(negative sampling) 训练速度要快很多倍，并且准确率也更高。</li>
<li>wordNgrams 默认为1，设置为2以上可以明显提高准确率。</li>
<li>如果词数不是很多，可以把bucket设置的小一点，否则预留会预留太多bucket使模型太大。</li>
</ul>
<p>因为facebook提供的只是C++版本的代码，上github已经有封装的python接口。用起来特别方便，觉得还不能满足自己的使用要求，修改源码也非常方便。<br>所以对于文本分类，先用fasttext做一个简单的baseline是很适合的。</p>
<h1 id="fastText-分类示例"><a href="#fastText-分类示例" class="headerlink" title="fastText 分类示例"></a>fastText 分类示例</h1><p>classification-example.sh 示例说明，包含训练、测试和预测示例。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/usr/bin/env bash</div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta">#</span> Copyright (c) 2016-present, Facebook, Inc.</div><div class="line"><span class="meta">#</span> All rights reserved.</div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta">#</span> This source code is licensed under the BSD-style license found in the</div><div class="line"><span class="meta">#</span> LICENSE file in the root directory of this source tree. An additional grant</div><div class="line"><span class="meta">#</span> of patent rights can be found in the PATENTS file in the same directory.</div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta">#</span> 对文本进行预处理并且打乱</div><div class="line">myshuf() &#123;</div><div class="line">  perl -MList::Util=shuffle -e 'print shuffle(&lt;&gt;);' "$@";</div><div class="line">&#125;</div><div class="line"></div><div class="line">normalize_text() &#123;</div><div class="line">  tr '[:upper:]' '[:lower:]' | sed -e 's/^/__label__/g' | \</div><div class="line">    sed -e "s/'/ ' /g" -e 's/"//g' -e 's/\./ \. /g' -e 's/&lt;br \/&gt;/ /g' \</div><div class="line">        -e 's/,/ , /g' -e 's/(/ ( /g' -e 's/)/ ) /g' -e 's/\!/ \! /g' \</div><div class="line">        -e 's/\?/ \? /g' -e 's/\;/ /g' -e 's/\:/ /g' | tr -s " " | myshuf</div><div class="line">&#125;</div><div class="line"><span class="meta">#</span> 然后就是下载数据集，normalize数据集，normalize_text()包括了myshuf。训练集是dbpedia.train，测试集是dbpedia.test</div><div class="line">RESULTDIR=result</div><div class="line">DATADIR=data</div><div class="line"></div><div class="line">mkdir -p "$&#123;RESULTDIR&#125;"</div><div class="line">mkdir -p "$&#123;DATADIR&#125;"</div><div class="line"></div><div class="line">if [ ! -f "$&#123;DATADIR&#125;/dbpedia.train" ]</div><div class="line">then</div><div class="line">  wget -c "https://github.com/le-scientifique/torchDatasets/raw/master/dbpedia_csv.tar.gz" -O "$&#123;DATADIR&#125;/dbpedia_csv.tar.gz"</div><div class="line">  tar -xzvf "$&#123;DATADIR&#125;/dbpedia_csv.tar.gz" -C "$&#123;DATADIR&#125;"</div><div class="line">  cat "$&#123;DATADIR&#125;/dbpedia_csv/train.csv" | normalize_text &gt; "$&#123;DATADIR&#125;/dbpedia.train"</div><div class="line">  cat "$&#123;DATADIR&#125;/dbpedia_csv/test.csv" | normalize_text &gt; "$&#123;DATADIR&#125;/dbpedia.test"</div><div class="line">fi</div><div class="line"><span class="meta">#</span> 编译C++代码</div><div class="line">make</div><div class="line"><span class="meta">#</span> 根据训练集训练fasttext，输出训练的结果</div><div class="line">./fasttext supervised -input "$&#123;DATADIR&#125;/dbpedia.train" -output "$&#123;RESULTDIR&#125;/dbpedia" -dim 10 -lr 0.1 -wordNgrams 2 -minCount 1 -bucket 10000000 -epoch 5 -thread 4</div><div class="line"><span class="meta">#</span> 根据训练的结果以及测试集进行测试，得到准确率</div><div class="line">./fasttext test "$&#123;RESULTDIR&#125;/dbpedia.bin" "$&#123;DATADIR&#125;/dbpedia.test"</div><div class="line"><span class="meta">#</span> 根据训练的结果以及测试集，输出测试集的结果</div><div class="line">./fasttext predict "$&#123;RESULTDIR&#125;/dbpedia.bin" "$&#123;DATADIR&#125;/dbpedia.test" &gt; "$&#123;RESULTDIR&#125;/dbpedia.test.predict"</div></pre></td></tr></table></figure></p>
<h1 id="fastText-词向量示例"><a href="#fastText-词向量示例" class="headerlink" title="fastText 词向量示例"></a>fastText 词向量示例</h1><p>word-vector-example.sh 示例说明，包括用skip-gram模式训练和评估词向量的示例。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/usr/bin/env bash</div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta">#</span> Copyright (c) 2016-present, Facebook, Inc.</div><div class="line"><span class="meta">#</span> All rights reserved.</div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta">#</span> This source code is licensed under the BSD-style license found in the</div><div class="line"><span class="meta">#</span> LICENSE file in the root directory of this source tree. An additional grant</div><div class="line"><span class="meta">#</span> of patent rights can be found in the PATENTS file in the same directory.</div><div class="line"><span class="meta">#</span></div><div class="line"></div><div class="line">RESULTDIR=result</div><div class="line">DATADIR=data</div><div class="line"></div><div class="line">mkdir -p "$&#123;RESULTDIR&#125;"</div><div class="line">mkdir -p "$&#123;DATADIR&#125;"</div><div class="line"><span class="meta">#</span> 下载语料</div><div class="line">if [ ! -f "$&#123;DATADIR&#125;/fil9" ]</div><div class="line">then</div><div class="line">  wget -c http://mattmahoney.net/dc/enwik9.zip -P "$&#123;DATADIR&#125;"</div><div class="line">  unzip "$&#123;DATADIR&#125;/enwik9.zip" -d "$&#123;DATADIR&#125;"</div><div class="line">  perl wikifil.pl "$&#123;DATADIR&#125;/enwik9" &gt; "$&#123;DATADIR&#125;"/fil9</div><div class="line">fi</div><div class="line"><span class="meta">#</span> 下载测试集</div><div class="line">if [ ! -f "$&#123;DATADIR&#125;/rw/rw.txt" ]</div><div class="line">then</div><div class="line">  wget -c https://nlp.stanford.edu/~lmthang/morphoNLM/rw.zip -P "$&#123;DATADIR&#125;"</div><div class="line">  unzip "$&#123;DATADIR&#125;/rw.zip" -d "$&#123;DATADIR&#125;"</div><div class="line">fi</div><div class="line"><span class="meta">#</span> 编译源代码</div><div class="line">make</div><div class="line"><span class="meta">#</span> 用skipgram模式进行训练</div><div class="line">./fasttext skipgram -input "$&#123;DATADIR&#125;"/fil9 -output "$&#123;RESULTDIR&#125;"/fil9 -lr 0.025 -dim 100 \</div><div class="line">  -ws 5 -epoch 1 -minCount 5 -neg 5 -loss ns -bucket 2000000 \</div><div class="line">  -minn 3 -maxn 6 -thread 4 -t 1e-4 -lrUpdateRate 100</div><div class="line"></div><div class="line">cut -f 1,2 "$&#123;DATADIR&#125;"/rw/rw.txt | awk '&#123;print tolower($0)&#125;' | tr '\t' '\n' &gt; "$&#123;DATADIR&#125;"/queries.txt</div><div class="line"></div><div class="line">cat "$&#123;DATADIR&#125;"/queries.txt | ./fasttext print-word-vectors "$&#123;RESULTDIR&#125;"/fil9.bin &gt; "$&#123;RESULTDIR&#125;"/vectors.txt</div><div class="line"><span class="meta">#</span> 评估训练的词向量</div><div class="line">python eval.py -m "$&#123;RESULTDIR&#125;"/vectors.txt -d "$&#123;DATADIR&#125;"/rw/rw.txt</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> WordEmbedding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fastText </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[词向量工具---GloVe使用教程]]></title>
      <url>/2017/11/11/glove-tools-using-tutorial/</url>
      <content type="html"><![CDATA[<p>基于统计的词向量模型以基于SVD分解技术的LSA模型为代表，通过构建一个共现矩阵得到隐层的语义向量，充分利用了全局的统计信息。然而这类模型得到的语义向量往往很难把握词与词之间的线性关系（例如著名的King、Queen、Man、Woman等式）。基于预测的词向量模型则以基于神经网络的Skip-gram模型为代表，通过预测一个词出现在上下文里的概率得到embedding词向量。这类模型的缺陷在于其对统计信息的利用不充分，训练时间与语料大小息息相关。不过，其得到的词向量能够较好地把握词与词之间的线性关系，因此在很多任务上的表现都要略优于SVD模型。既然两种模型各有优劣，那么能不能二者各取其长，构造一个更强大的词向量模型呢？这就是接下来要介绍的GloVe模型。<br><a id="more"></a><br>GloVe是斯坦福大学提出的一种新的词矩阵生成的方法，GloVe全称应该是 Global Vectors for Word Representation，综合运用词的全局统计信息和局部统计信息来生成语言模型和词的向量化表示。<a href="http://nlp.stanford.edu/projects/glove/" target="_blank" rel="external">官方主页链接</a>，上面还有训练好的模型可以下载。<br>在GloVe的原始论文里，作者首先分析了Skip-gram模型能够挖掘出词与词之间线性关系的背后成因，然后通过在共现矩阵上构造相似的条件，得到一个基于全局信息的词向量模型——GloVe模型。<br>与Skip-gram模型相比，GloVe在充分利用了语料库的全局统计信息的同时，也提高了词向量在大语料上的训练速度（一个共现矩阵的遍历要比整个语料库的遍历容易的多）。而与传统的SVD技术相比，SGD的训练也更加简单高效。同时，GloVe得到的词向量更能把握住词与词之间的线性关系。<br>GloVe综合了LSA、CBOW的优点，训练更快、对于大规模语料算法的扩展性也很好、在小语料或者小向量上性能表现也很好。<br>和绝大多数的词向量不同，glove的目标是通过训练词向量和上下文向量，使得它们能够重构共现矩阵。<br>需要注意的是，在运行glove时，对内存要求比较高，1.4G的语料，20G的内存都无法运行，一直死机；后面降到300M的语料，20G的内存基本上能够运行。而gensim中的word2vec，对于1.4G的语料，20G完全可以运行，而且只需要几个小时就能跑出结果。</p>
<p>glove在三元组上面进行训练, glove是根据每个三元组去更新一次词向量和上下文向量<br>GloVe训练参数:</p>
<ul>
<li>最佳的向量维度：300左右，之后变化比较轻微</li>
<li>对于GloVe向量来说最佳的窗口长度是8</li>
<li>训练迭代次数越大，对于GloVe来说确实有助于达到更好的效果<br><img src="/images/glove/paper_figure3.png" alt="在不同语料库训练的300维向量在类比任务上的精度对比"></li>
<li>更多的数据有助于帮助提高训练精度<br><img src="/images/glove/paper_figure4.png" alt="GloVe与CBOW、Skip-Gram的对比"></li>
</ul>
<p><a href="https://nlp.stanford.edu/pubs/glove.pdf" target="_blank" rel="external">论文链接</a></p>
<p>GloVe实现：<br>目前开源的有C语言版本、Python版本和R语言版本。<br>python：python-glove</p>
<p>Python版本<a href="https://github.com/maciejkula/glove-python" target="_blank" rel="external">GitHub地址</a><br>安装<br>pip install glove_python</p>
<p><strong><code>GloVe</code></strong>之<strong><code>C</code></strong>语言版本<a href="https://github.com/stanfordnlp/GloVe" target="_blank" rel="external">GitHub地址</a><br>跑在linux下<br>那就只能用C的代码训练，然后再用python来处理结果。让人欣喜的是，GloVe训练的结果，是可以用gensim里面word2vec的load直接加载并且使用的(将参数write_header设置为1，会在 <strong><code>vectors.txt</code></strong> 的首行添加&lt;词表大小&gt;/&lt;词向量大小&gt;)，那就简单了。</p>
<h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git clone http://github.com/stanfordnlp/glove</div></pre></td></tr></table></figure>
<h1 id="切换到glove目录"><a href="#切换到glove目录" class="headerlink" title="切换到glove目录"></a>切换到glove目录</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> cd glove</div></pre></td></tr></table></figure>
<p>首先先参考 <strong><code>README.txt</code></strong>，里面主要介绍这个程序包含了四部分子程序，按步骤分别是<strong><code>vocab_count</code></strong>、<strong><code>cooccur</code></strong>、<strong><code>shuffle</code></strong>、<strong><code>glove</code></strong>。</p>
<h2 id="vocab-count"><a href="#vocab-count" class="headerlink" title="vocab_count"></a>vocab_count</h2><p>用于统计文本中的词的词频，生成 <strong><code>vocab.txt</code></strong>，每一行为：词  词频。</p>
<h2 id="cooccur"><a href="#cooccur" class="headerlink" title="cooccur"></a>cooccur</h2><p>用于统计词与词的共现，目测类似与 <strong><code>word2vec</code></strong> 的窗口内的任意两个词，生成二进制文件 <strong><code>cooccurrence.bin</code></strong>。</p>
<h2 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h2><p>对 <strong><code>cooccurrence.bin</code></strong>中的共现结果重新整理。对于大文件，文件自动分割成块，每个块 <strong><code>shuffle</code></strong> 后再合并在一起，生成二进制文件 <strong><code>cooccurrence.shuf.bin</code></strong>。</p>
<h2 id="glove"><a href="#glove" class="headerlink" title="glove"></a>glove</h2><p><strong><code>GloVe</code></strong> 算法的训练模型，使用之前生成的<strong><code>vocab.txt</code></strong>和 <strong><code>cooccurrence.shuf.bin</code></strong>，最终会输出词典中词对应的词向量 <strong><code>vectors.txt</code></strong>和词向量二进制文件 <strong><code>vectors.bin</code></strong>。（</p>
<h1 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> make</div></pre></td></tr></table></figure>
<p>确保安装了 <strong><code>gcc</code></strong> ，生成一个 <strong><code>build</code></strong> 的文件夹</p>
<h1 id="Demo测试"><a href="#Demo测试" class="headerlink" title="Demo测试"></a><strong><code>Demo</code></strong>测试</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ./demo.sh</div></pre></td></tr></table></figure>
<p><a href="https://github.com/stanfordnlp/GloVe" target="_blank" rel="external">GitHub地址</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[词向量工具---word2vec简介、使用教程及源码分析]]></title>
      <url>/2017/11/05/word2vec-tools-using-tutorial/</url>
      <content type="html"><![CDATA[<p>word2vec 是 Google 于 2013 年开源推出的一个用于获取词向量的工具包，它简单、高效，因此引起了很多人的关注。word2vec 的作者 Tomas Mikolov 在以下两篇论文介绍了相应的理论基础：</p>
<blockquote>
<p><a href="https://arxiv.org/pdf/1301.3781.pdf" target="_blank" rel="external">Efficient Estimation of Word Representations in Vector Space</a> </p>
<p><a href="https://arxiv.org/pdf/1310.4546.pdf" target="_blank" rel="external">Distributed Representations of Words and Phrases and their Compositionality</a></p>
</blockquote>
<a id="more"></a>
<p>原始论文没有谈及太多算法细节，解释得不够清晰，因而在一定程度上增加了这个工具包的神秘感并没有中文。想了解一下 word2vec 的数学原理，推荐 peghoty 大神的系列博客<a href="http://blog.csdn.net/itplus/article/details/37969519" target="_blank" rel="external">《word2vec 中的数学原理详解》</a> ，博主也是通过阅读该系列博客学习 word2vec 中的数学原理和实现细节，在此推荐给大家。</p>
<p>word2vec 就是“两个训练方案＋两个提速手段”，两两组合，因此也就有了四个备选的模型。</p>
<h2 id="两个训练方案"><a href="#两个训练方案" class="headerlink" title="两个训练方案"></a>两个训练方案</h2><p>CBOW (Continuous Bag-of-Words Model) 和 Skip-gram（Continuous Skip-gram Model）。<br>结构如图所示：<br><img src="/images/word2vec/architectures" alt="word2vec的CBOW和Skip-gram结构图"></p>
<p>两个模型都是只有三层，即输入层、映射层和输出层。<br>CBOW 可以理解为”将周围词叠加来预测当前次”，用上下文的词向量作为输入，映射层在所有的词间共享，输出层为一个分类器，目标是使当前词的概率最大。<br>Skip-gram 可以理解为”根据当前词分别预测周围词”，输入层为当前词向量，输出层是使得上下文的预测概率最大。训练采用SGD。<br>按理论来说，skip gram比cbow需要花window ~ 2 * window倍的时间。cbow是把2<em>window个词作为输入，一个词作为输出，这样构成训练样本。而skip gram相当于将这2 \</em> window个词拆成了2 * window个样本。</p>
<h2 id="两个提速手段"><a href="#两个提速手段" class="headerlink" title="两个提速手段"></a>两个提速手段</h2><p>Hierarchical Softmax 和 Negative Sampling。<br>Hierarchical Softmax 是对softmax的简化，精度会比原生的softmax略差，但是预测概率的效率从O(|V|)降到O(log2|V|)，是word2vec中用于提高性能的一项关键技术。<br>Negative Sampling 是 NCE(Noise Contrastive Estimation) 的一个简化版本，目的是用来提高训练速度并改善所得词向量的质量。与Hierarchical Softmax不同，Negative Sampling 不再使用复杂的Huffman树，而是利用相对简单的随机负采样，达到大幅度提高性能。</p>
<p>word2vec 将词的上下文关系嵌入到低维空间。更具体而言，word2vec 将词的上下文关系转换为分类关系，并以此同时训练词嵌入向量和 logistic regression 分类器。<br>逻辑回归logistic regression 是经典的线性分类模型。广义上而言，线性模型由三个部分组成， 1. 输入向量 2. 线性系数 3. 偏移(bias)，而 bias 可以进一步表示成线性系数。所以，二分类的线性分类问题可以表示为输入 $x$ 和系数 $w$ 的内积结果 $w^Tx$，结果的正负决定了数据的类别。分类器参数通过最小化损失函数 $l(y, w^Tx)$来完成，不同的损失函数定义了不同的分类模型。<br>logistic regression 也广泛地应用在多分类问题中，通过 softmax 函数计算数据属于每个类别的概率完成分类。因为分类神经网络的输出层通常也设定为 softmax 函数，所以多分类 lr 也可以表示为浅层神经网络。</p>
<p>cbow 用上下文词向量的加和结果来预测其中心词汇。<br>skip-gram我们将词的上下文定义为以词 $w_i$ 为中心，窗口为 $k$ 前后范围内的词 $C<em>i = {w</em>{i-k}, w<em>{i-k+1}, …, w</em>{i-1}, w<em>{i+1}, … w</em>{i+k}}$。<br>skip-gram 将词之间的关系变成了 $|V|$ 多分类问题，其中 $|V|$ 是词库大小。每个词有两个变量 $x_i, w_i$，前者为词嵌入向量，后者是线性分类器的系数，在相关文章中又称为上下文向量。<br>skip-gram 用中心词汇来预测其上下文<br>针对多分类的计算优化word2vec 将上下文关系转化为多分类任务，进而训练逻辑回归模型，这里的类别数量是 $|V|$ 词库大小。通常的文本数据中，词库少则数万，多则百万，在训练中直接训练多分类逻辑回归并不现实。<br>word2vec [5] 中提供了两种针对大规模多分类问题的优化手段， negative sampling 和 hierarchical softmax。以 skip-gram 为例，中心词对上下文的词类是正面例子，对所有其它的词则是负面例子。在优化中，negative sampling 只更新少量负面类，从而减轻了计算量。hierarchical softmax 将词库表示成前缀树，从树根到叶子的路径可以表示为一系列二分类器，一次多分类计算的复杂度从 $|V|$ 降低到了树的高度。<br>嵌入技术将词的上下文关系嵌入到低维空间。word2vec 将词的局部上下文转化为了多分类任务，从而训练逻辑回归模型，并将逻辑回归模型中的输入部分作为词嵌入输出。<br>首先简单说一下word2vec的使用方式。word2vec的官方下载地址是 <a href="https://code.google.com/archive/p/word2vec/" target="_blank" rel="external">https://code.google.com/archive/p/word2vec/</a> 。到source里面找到download下载就可以。word2vec可以直接在linux上和macos上面运行，但是不能直接在windows上面运行，原因是windows没有pthread库。把pthread依赖去掉可以单线程跑，但是实在是太慢了。也可以安装这个库，但是比较麻烦，这里就不深入探讨了。</p>
<h2 id="测试数据集"><a href="#测试数据集" class="headerlink" title="测试数据集"></a>测试数据集</h2><p>question-words.txt和question-phrases.txt是用来衡量词向量/短语向量质量的词类比（analogy）数据集。<br>question-words.txt每一行是四个单词，我们需要根据前三个单词推断出第四个单词是什么。每一行像这样：Berlin Germany London England。<br>question-phrases.txt数据集中是包含了短语的analogy问题，像这样：Jeff_Bezos Amazon Tim_Cook Apple</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>makefile文件对几个c语言文件进行编译生成可执行文件。<br>word2vec.c<br>这个工具包中最重要的文件就是word2vec.c。它读入语料然后训练得到词向量。其他的c文件实现了一些边角辅助功能。<br>word2phrase.c<br>会过滤一遍要训练的语料，识别出语料中哪些是短语（比如把Tim Cook识别成一个短语Tim_Cook），把短语当做一个新词，输出出去。<br>distance.c<br>的功能是输入一个单词，返回最接近的单词（比如给beijing返回shanghai，heilongjiang）以及它们的词向量和输入单词的词向量的Cosine夹角。<br>word-analogy.c<br>的功能是输入三个单词（比如wife king queen），返回第四个单词（比如husband）。<br>compute-accuracy.c的功能是定量的给出词向量在analogy数据集上面的准确率。</p>
<p>1、word2vec<br>word2vec：与一般的共现计数不同，word2vec主要来预测单词周边的单词,在嵌入空间里相似度的维度可以用向量的减法来进行类别测试。</p>
<p>弊端：</p>
<p>1、对每个local context window单独训练，没有利用包含在global co-corrence矩阵中的统计信息<br>2、多义词处理乏力，因为使用了唯一词向量</p>
]]></content>
      
        <categories>
            
            <category> 词向量 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> word2vec </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[词向量简介]]></title>
      <url>/2017/11/01/word-vector-abstract/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>自然语言是一套用来表达含义的复杂系统。在这套系统中，词是表义的基本单元。在 <strong><code>NLP</code></strong> 领域中，如何量化词的表达也是关键问题之一。用某个固定维度的向量(<strong><code>vector</code></strong>)去表示词是一个很经典很基本的任务，我们称这个向量为「词向量」，通常也被认为是词的特征向量。我们之所以要把单词变成向量是因为我们需要把自然语言抽象成数学中的某个概念（这里是向量）。换一种更具体直白的说法，之所以要把单词变成固定维度的向量，是因为绝大多数的机器学习(<strong><code>Machine Learning</code></strong>)模型需要固定维度的向量作为输入。近年来，「词向量」已逐渐成为自然语言处理的基础知识，一份高质量的「词向量」是很多任务取得更好表现的关键。常见的方式有以下两种：</p>
<blockquote>
<ol>
<li>独热编码(One-Hot Encoding)</li>
<li>词嵌入(Word Embedding)</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="独热编码-One-Hot-Encoding"><a href="#独热编码-One-Hot-Encoding" class="headerlink" title="独热编码(One-Hot Encoding)"></a>独热编码(One-Hot Encoding)</h1><p>独热编码即 <strong><code>One-Hot</code></strong> 编码，又称一位有效编码，直观来说就是使用 <strong><em><code>N</code></em></strong> 位状态寄存器对 <strong><em><code>N</code></em></strong> 个状态进行编码，每个状态都有其独立的寄存器位，并且在任意时候有且只有一位有效，即只有一个值为 <strong><code>1</code></strong>，其他值全为 <strong><code>0</code></strong> 的一种码制。在机器学习的任务中，对于离散型的分类型的数据，需要对其进行数字化，比如说「性别」这一属性，只能有「男性」、「女性」或者「其他」这三种值，如何对这三个值进行数字化表达呢？一种简单的方式就是「男性」为 <strong><code>0</code></strong>，「女性」为 <strong><code>1</code></strong>，「其他」为 <strong><code>2</code></strong>。使用上面简单的方式对分类值进行数字化后，进行模型训练时可能会产生一个问题：特征因为数字值的不同影响模型的训练效果，在模型训练的过程中不同的值使得同一特征在样本中的权重可能发生变化。假如直接编码成 <strong><code>100</code></strong>，是不是比编码成 <strong><code>1</code></strong> 对模型的的影响更大？为了解决上述的问题，使训练过程中不受到因为分类值数字化的问题对模型产生的负面影响，引入独热码对分类型的特征进行独热码编码。</p>
<p>在 <strong><code>NLP</code></strong> 任务中，假设词典中不同词的数量为 <strong><em><code>N</code></em></strong>，每个词的 <strong><code>index</code></strong> 都与 <strong><code>0</code></strong> 到 <strong><em><code>N-1</code></em></strong> 的连续整数一一对应。假设一个词的下标为 <strong><em><code>i</code></em></strong>，为了得到该词的 <strong><code>One-Hot</code></strong> 向量表示，我们创建一个全 <strong><code>0</code></strong> 的长为 <strong><em><code>N</code></em></strong>的向量，并将其第 <strong><em><code>i</code></em></strong>位置成 <strong><code>1</code></strong>。<strong><code>One-Hot</code></strong> 编码使用了高维稀疏向量表示词，这样的特征可以反映词出现的频率，但这并不是最好的选择。一个主要的原因是，<strong><code>One-Hot</code></strong> 词向量无法表达不同词之间的关系，例如「相似度」这一度量关系。任何一对词的 <strong><code>One-Hot</code></strong> 向量的余弦相似度都为 <strong><code>0</code></strong>。</p>
<p>那究竟用什么向量去表示词才是合理的呢？一个符合直觉的想法是，相似的词应该有相似的「词向量」，比如 <strong><code>dog</code></strong> 和 <strong><code>cat</code></strong> 这两个词，他们的意思很相近，那么他们的「词向量」也应该很相似，或者说他们的「词向量」在空间中位置很接近，距离很短。再比如 <strong><code>dog</code></strong> 和 <strong><code>rocket</code></strong> 这两个词，他们的「词向量」在空间中位置应该距离比较远。我们应该怎样做才能使得相似的词有相似的「词向量」呢？</p>
<h1 id="词嵌入-Word-Embedding"><a href="#词嵌入-Word-Embedding" class="headerlink" title="词嵌入(Word Embedding)"></a>词嵌入(Word Embedding)</h1><p>目前大多数人所述的「词向量」，其实指的就是「词嵌入」。与 <strong><code>One-Hot</code></strong> 编码相比而言，「词嵌入」技术将词汇的上下文关系嵌入到一个低维空间。举一个简单的例子，在字典用我们会用几千个常用词去解释每个词的意思，而「词向量」中，我们用(比如) <strong><code>100</code></strong> 维的实数向量去表示字典中的词。换一种说法，我们要把字典中每一个词映射到某个维度(比如 <strong><code>100</code></strong> 维)的空间当中去，所以我们也可以把「词向量」叫做「空间向量模型」(<strong><code>Vector Space Model</code></strong>)。「词嵌入」模型几乎都利用了语言学中这样的一个规律：相似的词有着相似的上下文。这个规律叫 <strong><code>Distributional Hypothesis</code></strong>。原理基本都是词的上下文的分布可以揭示这个词的语义，就好比“看看你跟什么样的人交往，就知道你是什么样的人”，所以「词向量」模型的核心就是对上下文的关系进行建模。还是以 <strong><code>dog</code></strong> 和 <strong><code>cat</code></strong> 两个词为例，他们是比较相似的单词，他们在语料中的上下文也很相近。他们的上下文中一般都会出现关于动物、宠物的单词或短语。所以，目前主流的「词向量」模型表面上千差万别，但是本质都很相似，都是对词与其上下文的关系进行建模，从而得到高质量的「词向量」。目前比较有代表性的工具有 <strong><code>word2vec</code></strong>、<strong><code>GloVe</code></strong> 和 <strong><code>fastText</code></strong> 等。</p>
<h1 id="词类比-Word-Analogy"><a href="#词类比-Word-Analogy" class="headerlink" title="词类比(Word Analogy)"></a>词类比(Word Analogy)</h1><p>上面已经提到，「词向量」会把相似的词映射到空间中相近的位置中去。所以我们可以用「词向量」找到和某个词相近的词。除此之外，「词向量」还有另一个比较优美的性质，「词类比」(<strong><code>Word Analogy</code></strong>)。在词类比任务中，我们需要通过前三个单词，例如 <strong><code>Athens</code></strong>、<strong><code>Greece</code></strong>、<strong><code>Baghdad</code></strong>，推导出第四个单词 <strong><code>Iraq</code></strong>。推导的过程就是「雅典」和「希腊」是首都的关系，「巴格达」和谁是首都的关系？答案是「伊拉克」。要做好这个任务，就要求我们还需要从「词向量」中得到词之间关系的信息，比如在上述例子中，这个关系就是「首都」。当年 <strong><code>word2vec</code></strong> 出现以后受到大家广泛关注，一个可能的原因就是大家惊讶于「词向量」能在 <strong><code>Word Analogy</code></strong>数据集上取得这么好的效果，原来「词向量」还有这样神奇的性质。</p>
<p>那「词向量」为何有能力做好 <strong><code>Word Analogy</code></strong> 这个任务呢？在 <strong><code>word2vec</code></strong> 中用 <strong><code>vec(&#39;wife&#39;) + vec(&#39;king&#39;) - vec(&#39;queen&#39;)</code></strong> 去寻找 <strong><code>husband</code></strong> 这个词，这种加加减减的操作看似没有什么道理，这里先给一个例子帮助大家直观的理解。我们以 <strong><code>king</code></strong>、<strong><code>queen</code></strong> 这两个词为例。假设语料中 <strong><code>king</code></strong> 周围出现的词主要和「皇室」这个主题以及「男性」这个主题有关。<strong><code>queen</code></strong> 周围出现的词主要和「皇室」这个主题和「女性」这个主题有关。我们令 <strong><code>vec(&#39;皇室&#39;)</code></strong>为所有有关「皇室」主题的词的「词向量」的平均，<strong><code>vec(&#39;男性&#39;)</code></strong> 和 <strong><code>vec(&#39;女性&#39;)</code></strong> 分别为所有有关「男性」和「女性」主题的词的「词向量」的平均。我们在上面内容中提到过，词的语义能通过它在语料中的上下文中的信息体现出来。我们这里就认为 <strong><code>vec(&#39;king&#39;) = 1/2(vec(&#39;皇室&#39;) + vec(&#39;男性&#39;))</code></strong>，<strong><code>vec(&#39;queen&#39;) = 1/2(vec(&#39;皇室&#39;) + vec(&#39;女性&#39;))</code></strong>。所以 <strong><code>vec(&#39;king&#39;) - vec(&#39;queen&#39;)</code></strong> 就等于 <strong><code>1/2(vec(&#39;男性&#39;)-vec(&#39;女性&#39;))</code></strong>。同理，对于 <strong><code>husband</code></strong>、<strong><code>wife</code></strong> 这两个词，<strong><code>husband</code></strong> 周围的词是关于「伴侣」和「男性」的主题，<strong><code>wife</code></strong> 周围的词是关于<br>「伴侣」和「女性」的主题。<strong><code>vec(&#39;husband&#39;) - vec(&#39;wife&#39;)</code></strong> 同样等于 <strong><code>1/2(vec(&#39;男性&#39;)- vec(&#39;女性&#39;))</code></strong>。这样 <strong><code>vec(&#39;husband&#39;) - vec(&#39;wife&#39;)</code></strong> 就等于 <strong><code>vec(&#39;king&#39;) - vec(&#39;queen&#39;)</code></strong>，我们就能轻易的通过三个词，去推断出第四个词。而 <strong><code>vec(&#39;king&#39;) - vec(&#39;queen&#39;)</code></strong> 也很好的反映了「男性」与「女性」这样一个关系。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在之后的「词向量」系列博文中，我会全面细致的解析包括 <strong><code>word2vec</code></strong>、<strong><code>GloVe</code></strong> 和 <strong><code>fastText</code></strong> 等一系列「词向量」工具包。通过上面提到的工具包，我们可以得到高质量的「词向量」，也可以根据我们的需求，得到不同性质的「词向量」。</p>
]]></content>
      
        <categories>
            
            <category> 词向量 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 词向量 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++学习笔记---map容器使用教程]]></title>
      <url>/2017/10/27/cpp-container-map-use-tutorial/</url>
      <content type="html"><![CDATA[<p>注意事项:</p>
<ol>
<li>在<strong><code>map</code></strong>中，由<strong><code>key</code></strong>查找<strong><code>value</code></strong>时，首先要判断<strong><code>map</code></strong>中是否包含<strong><code>key</code></strong>。</li>
<li>如果不检查，直接返回<strong><code>map[key]</code></strong>，可能会出现意想不到的行为。如果<strong><code>map</code></strong>包含<strong><code>key</code></strong>，没有问题，如果<strong><code>map</code></strong>不包含<strong><code>key</code></strong>，使用下标有一个危险的副作用，会在<strong><code>map</code></strong>中插入一个<strong><code>key</code></strong>的元素，<strong><code>value</code></strong>取默认值，返回<strong><code>value</code></strong>。也就是说，<strong><code>map[key]</code></strong>不可能返回<strong><code>null</code></strong>。</li>
<li><strong><code>map</code></strong>提供了两种方式，查看是否包含<strong><code>key</code></strong>，<strong><code>map.count(key)</code></strong>、<strong><code>map.find(key)</code></strong>。</li>
<li><strong><code>map.count(key)</code></strong>：由于<strong><code>map</code></strong>不包含重复的<strong><code>key</code></strong>，因此<strong><code>map.count(key)</code></strong>取值为<strong><code>0</code></strong>，表示不包含，取值为<strong><code>1</code></strong>，表示包含。</li>
<li><strong><code>map.find(key)</code></strong>：返回迭代器，判断是否存在。</li>
<li>对于<strong><code>STL</code></strong>中的容器，有泛型算法<strong><code>find(begin，end，target)</code></strong>查找目标，<strong><code>map</code></strong>还提供了一个成员方法<strong><code>find(key)</code></strong>。</li>
<li>对于下面的场景，存在<strong><code>key</code></strong>就使用，否则返回<strong><code>null</code></strong>，有下面两种写法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="number">1</span> == <span class="built_in">map</span>.count(key)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">map</span>[key];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> null;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iter = <span class="built_in">map</span>.find(key);</div><div class="line"><span class="keyword">if</span>(iter != <span class="built_in">map</span>.end()) &#123;</div><div class="line">    <span class="keyword">return</span> iter-&gt;second;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> null;</div></pre></td></tr></table></figure>
<p>这里需要注意：前一种方法很直观，但是效率差很多。因为前面的方法，需要执行两次查找。因此，推荐使用后一种方法。</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++,container </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++学习笔记---vector容器使用教程]]></title>
      <url>/2017/10/21/cpp-container-vector-use-tutorial/</url>
      <content type="html"><![CDATA[<h1 id="利用-remove-if-和-erase-从-vector-中移除指定-set-中包含的元素"><a href="#利用-remove-if-和-erase-从-vector-中移除指定-set-中包含的元素" class="headerlink" title="利用 remove_if() 和 erase() 从 vector 中移除指定 set 中包含的元素"></a>利用 <code>remove_if()</code> 和 <code>erase()</code> 从 <code>vector</code> 中移除指定 <code>set</code> 中包含的元素</h1><a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; replace_str_set&#123;<span class="string">","</span>, <span class="string">"."</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsReplaceStr</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (replace_str_set.find(str) != replace_str_set.end()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; string_vector&#123;<span class="string">"a"</span>, <span class="string">","</span>, <span class="string">"b"</span>, <span class="string">"."</span>, <span class="string">"c"</span>&#125;;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator it;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"before replace: "</span>;</div><div class="line">    <span class="keyword">for</span> (it = string_vector.begin(); it != string_vector.end(); it++) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it; &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    string_vector.erase(remove_if(string_vector.begin(), string_vector.end(), IsReplaceStr), string_vector.end());</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after replace: "</span>;</div><div class="line">    <span class="keyword">for</span> (it = string_vector.begin(); it != string_vector.end(); it++) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">before replace: a,b.c</div><div class="line">after replace: abc</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++,container </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++学习笔记---容器(container)使用教程]]></title>
      <url>/2017/10/20/cpp-container-use-tutorial/</url>
      <content type="html"><![CDATA[<p>在 <strong><code>C++</code></strong> 的 <strong><code>STL</code></strong> 中，常见的容器可分为<strong>「顺序容器」(sequential container)</strong> 和<strong>「关联容器」(associative container)</strong>。<br><a id="more"></a></p>
<p>标准的 <strong><code>STL</code> 「顺序容器」</strong>包括：</p>
<p><strong><code>vector</code></strong>、<strong><code>deque</code></strong>、<strong><code>list</code></strong>、<strong><code>forward_list</code></strong>、<strong><code>array</code></strong> 与 <strong><code>string</code></strong>。</p>
<p>标准的 <strong><code>STL</code>「关联容器」</strong>可分为<strong>「关键字有序」</strong>和<strong>「关键字无序」</strong>。</p>
<p>关键字有序：<strong><code>map</code></strong>、<strong><code>set</code></strong>、<strong><code>multimap</code></strong>和<strong><code>multiset</code></strong>。</p>
<p>关键字无序： <strong><code>unorder_map</code></strong>、<strong><code>unorder_set</code></strong>、<strong><code>unorder_multimap</code></strong>和<strong><code>unorder_multiset</code></strong>。</p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a><strong><code>vector</code></strong></h3><p><strong><code>vector</code></strong>将元素保存在连续的内存空间中，支持随机存取。由于元素是连续存储的，在这两种容器中间插入和删除元素，需要修改该位置之后所有元素的位置，效率较低。如果不清楚元素的确切个数，请使用<strong><code>vector</code></strong>，如果清楚元素的确切个数，请使用数组。</p>
<h3 id="string、"><a href="#string、" class="headerlink" title="string、"></a><strong><code>string</code></strong>、</h3><p><strong><code>string</code></strong>将元素保存在连续的内存空间中，支持随机存取。由于元素是连续存储的，在这两种容器中间插入和删除元素，需要修改该位置之后所有元素的位置，效率较低。</p>
<h3 id="list、forward-list"><a href="#list、forward-list" class="headerlink" title="list、forward_list"></a><strong><code>list</code></strong>、<strong><code>forward_list</code></strong></h3><p><strong><code>list</code></strong>和<strong><code>forward_list</code></strong>分别对应数据结构中的双向链表和单向链表。两个容器将元素的设计目的是让容器在任何位置的插入和删除效率提高，但其代价是容器不支持随机存取，查找效率较低。</p>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a><strong><code>deque</code></strong></h3><p><strong><code>deque</code></strong>是一种更为复杂的数据结构。与<strong><code>string</code></strong>和<strong><code>vector</code></strong>类似，支持快速随机访问，并且在其两端添加和删除元素的效率都很高。但是，由于<strong><code>deque</code></strong>中元素也是连续存储，在其中间插入和删除元素的效率也较低。</p>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a><strong><code>array</code></strong></h3><p><strong><code>array</code></strong>是一种更安全的数组，与内置数组类似，不支持动态内存分配，支持元素随机访问。</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++,container </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TensorFlow Tensor变换API]]></title>
      <url>/2017/10/19/tensorflow-tensor-transform-api/</url>
      <content type="html"><![CDATA[<h1 id="tf-stack"><a href="#tf-stack" class="headerlink" title="tf.stack()"></a>tf.stack()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">stack(</div><div class="line">    values, </div><div class="line">    axis=0, </div><div class="line">    name=&quot;stack&quot;</div><div class="line">)</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>官方文档：</p>
<blockquote>
<p><a href="https://www.tensorflow.org/api_docs/python/tf/stack" target="_blank" rel="external">https://www.tensorflow.org/api_docs/python/tf/stack</a></p>
</blockquote>
<p>定义：</p>
<blockquote>
<p><a href="https://github.com/tensorflow/tensorflow/blob/r1.3/tensorflow/python/ops/array_ops.py" target="_blank" rel="external">tensorflow/python/ops/array_ops.py</a></p>
</blockquote>
<p>功能：</p>
<blockquote>
<p>将由 <code>R</code> 维的 <code>tensor</code> 堆成 <code>R+1</code> 维的 <code>tensor</code> .</p>
</blockquote>
<p>说明：</p>
<blockquote>
<p>通过沿着 <code>axis</code> 维，将 <code>values</code> 中的 <code>tensor</code> 列表填充到一个比<code>values</code> 中的 <code>tensor</code> 高一维的 <code>tensor</code>中。</p>
<p>给定一个长度为 <code>N</code> ，由 <code>shape</code> 为 <code>（A，B，C）</code> 的 <code>tensor</code> 构成的列表；</p>
<p>如果 <code>axis == 0</code>，输出的  <code>tensor</code> 的 <code>shape</code> 为 <code>(N, A, B, C)</code></p>
<p>如果 <code>axis == 1</code>，输出的  <code>tensor</code> 的 <code>shape</code> 为 <code>(A, N, B, C)</code></p>
</blockquote>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line">x = [<span class="number">1</span>, <span class="number">4</span>]</div><div class="line">y = [<span class="number">2</span>, <span class="number">5</span>]</div><div class="line">z = [<span class="number">3</span>, <span class="number">6</span>]</div><div class="line"></div><div class="line">stack_0 = tf.stack([x, y, z])</div><div class="line"><span class="keyword">print</span> (stack_0.get_shape())     <span class="comment"># (3, 2)</span></div><div class="line">stack_1 = tf.stack([x, y, z], axis=<span class="number">1</span>)</div><div class="line"><span class="keyword">print</span> (stack_1.get_shape())     <span class="comment"># (2, 3)</span></div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    stack_0_val, stack_1_val = sess.run([stack_0, stack_1])</div><div class="line">    <span class="keyword">print</span> (<span class="string">'stack_0_val:'</span>)</div><div class="line">    <span class="keyword">print</span> (stack_0_val)     <span class="comment"># [[1, 4], [2, 5], [3, 6]]</span></div><div class="line">    <span class="keyword">print</span> (<span class="string">'stack_0_val.shape: %s'</span> % str(stack_0_val.shape))     <span class="comment"># (3, 2)</span></div><div class="line">    <span class="keyword">print</span> (<span class="string">'stack_1_val:'</span>)</div><div class="line">    <span class="keyword">print</span> (stack_1_val)     <span class="comment"># [[1, 2, 3], [4, 5, 6]]</span></div><div class="line">    <span class="keyword">print</span> (<span class="string">'stack_1_val.shape: %s'</span> % str(stack_1_val.shape))     <span class="comment"># (2, 3)</span></div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">stack_0.get_shape(): (3, 2)</div><div class="line">stack_1.get_shape(): (2, 3)</div><div class="line">stack_0_val:</div><div class="line">[[1 4]</div><div class="line"> [2 5]</div><div class="line"> [3 6]]</div><div class="line">stack_0_val.shape: (3, 2)</div><div class="line">stack_1_val:</div><div class="line">[[1 2 3]</div><div class="line"> [4 5 6]]</div><div class="line">stack_1_val.shape: (2, 3)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> TensorFlow </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TensorFlow的2种安装方法---pip安装和源码安装]]></title>
      <url>/2017/10/01/tensorflow-install/</url>
      <content type="html"><![CDATA[<p>本篇学习笔记是在 <strong><code>macOS</code></strong> 系统上进行的演示，<strong><code>python</code></strong> 版本为 <strong><code>2.7.10</code></strong>，如果大家想学习在 <strong><code>windows</code></strong>，<strong><code>linux</code></strong> 等系统上的安装步骤，可以参考一下官方的安装 <strong><code>TensorFlow</code></strong> 的方法：<a href="https://www.tensorflow.org/install/" target="_blank" rel="external">https://www.tensorflow.org/install/</a> ，个人建议在虚拟环境下安装 <strong><code>TensorFlow</code></strong>。下面介绍 <strong><code>TensorFlow</code></strong> 的2种安装方法。<br><a id="more"></a></p>
<h1 id="通过「pip」直接安装"><a href="#通过「pip」直接安装" class="headerlink" title="通过「pip」直接安装"></a>通过「pip」直接安装</h1><h2 id="安装「pip」"><a href="#安装「pip」" class="headerlink" title="安装「pip」"></a>安装「pip」</h2><p>如果已经安装，跳过此步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo easy_install pip</div></pre></td></tr></table></figure></p>
<p>查看 <strong><code>pip</code></strong> 是否安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip —version</div></pre></td></tr></table></figure></p>
<h2 id="安装「tensorflow」"><a href="#安装「tensorflow」" class="headerlink" title="安装「tensorflow」"></a>安装「tensorflow」</h2><p>安装CPU版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install tensorflow</div></pre></td></tr></table></figure></p>
<p>安装GPU版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install tensorflow-gpu</div></pre></td></tr></table></figure></p>
<p>注：默认安装都是最新版本，如需要安装指定版本，需要加上版本号<br>例如安装1.0.0版本<br>安装CPU版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install tensorflow==1.0.0</div></pre></td></tr></table></figure></p>
<p>安装GPU版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install tensorflow-gpu==1.0.0</div></pre></td></tr></table></figure></p>
<h1 id="通过源码安装"><a href="#通过源码安装" class="headerlink" title="通过源码安装"></a>通过源码安装</h1><pre><code>首先Mac下内置有gcc，可以通过终端命令gcc -v 查看：
</code></pre><p>其中的4.2.1就是gcc的版本，或者大家也可以直接输入终端命令python进行查看</p>
<p>里面有一个GCC 4.2.1，感觉比上面那个命令更直观一些。<br>然后就是要安装Google自家的编译工具bazel了，mac上最好的办法就是直接使用brew安装了：\<br>brew install bazel<br>安装好之后就要下载官方的TensorFlow源码了：<br>git clone <a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">https://github.com/tensorflow/tensorflow</a><br>下载完成后会在你的用户名的目录下生成一个tensorflow的文件夹，使用<br>cd tensorflow<br>进入这个文件夹，然后输入：<br>./configure<br>进行配置，通常情况下没有特殊的要求，一般全部都选择n，需要输入path的地方敲回车，使用默写path</p>
<p>配置完成后就是编译过程了，输入终端命令:<br>bazel build –config=opt //tensorflow/tools/pip_package:build_pip_package<br>经过漫长的编译后，任务就基本上完成了，接下来就是输入下面的命令来生成pip安装包了：<br>bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg<br>接下来安装这个wheel。如果之前pip装过tf的话，最好先卸载掉：<br>pip uninstall tensorflow<br>再安装<br>pip install /tmp/tensorflow_pkg/tensorflow-1.3.0-cp27-cp27m-macosx_10_12_intel.whl<br>安装成功<br>Installing collected packages: tensorflow<br>Successfully installed tensorflow-1.2.0<br>验证安装<br>遇到的问题：<br>如果错误是bazel相关的，请卸载bazel重新安装。</p>
]]></content>
      
        <categories>
            
            <category> TensorFlow </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python虚拟环境---virtualenv的安装及使用]]></title>
      <url>/2017/08/10/virtualenv-using-tutorial/</url>
      <content type="html"><![CDATA[<p>在开发 <strong><code>Python</code></strong> 应用程序的时候，系统安装的 <strong><code>Python</code></strong>只有一个版本，所有第三方的包都会被 <strong><code>pip</code></strong> 安装到 <strong><code>Python</code></strong> 的 <strong><code>site-packages</code></strong> 目录下。如果我们要同时开发多个应用程序，那这些应用程序都会共用这个安装在系统的 <strong><code>Python</code></strong>。如果 「应用A」 需要 <strong><code>Python 2.6</code></strong> 版本，而 「应用B」 需要 <strong><code>Python 2.7</code></strong> 版本，这种情况下共用这个安装在系统的 <strong><code>Python</code></strong> 版本就不能满足需求了，每个应用需要各自拥有一套「独立」的 <strong><code>Python</code></strong> 运行环境。<strong><code>virtualenv</code></strong> 就是用来为一个应用创建一套「独立」的 <strong><code>Python</code></strong> 运行环境，在虚拟环境下，用 <strong><code>pip</code></strong> 安装的包都被安装到虚拟环境 <strong><code>Python</code></strong> 的 <strong><code>site-packages</code></strong> 下，系统 <strong><code>Python</code></strong> 环境不受任何影响。<br><a id="more"></a></p>
<h1 id="安装「virtualenv」"><a href="#安装「virtualenv」" class="headerlink" title="安装「virtualenv」"></a>安装「virtualenv」</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install virtualenv</div></pre></td></tr></table></figure>
<p>查看 <strong><code>virtualenv</code></strong> 是否安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">virtualenv —version</div></pre></td></tr></table></figure></p>
<h1 id="创建「virtualenv」环境"><a href="#创建「virtualenv」环境" class="headerlink" title="创建「virtualenv」环境"></a>创建「virtualenv」环境</h1><p>切换到虚拟环境要存放的目录，创建虚拟环境:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">virtualenv &lt;env_name&gt;</div></pre></td></tr></table></figure></p>
<p>个人建议：</p>
<blockquote>
<p>虚拟环境与项目在同一目录下，并且虚拟环境以前缀 <strong><code>env_</code></strong> 加项目名来命名。<br>示例：<strong><code>machine_learning</code></strong> 是项目目录，<strong><code>env_machine_learning</code></strong> 是虚拟环境目录。</p>
</blockquote>
<h1 id="激活「virtualenv」环境"><a href="#激活「virtualenv」环境" class="headerlink" title="激活「virtualenv」环境"></a>激活「virtualenv」环境</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source &lt;env_name&gt;/bin/activate</div></pre></td></tr></table></figure>
<p>激活成功后，命令提示符有个(<strong><code>&lt;env_name&gt;</code></strong>)前缀，表示当前环境是一个名为 <strong><code>&lt;env_name&gt;</code></strong> 的 <strong><code>Python</code></strong> 虚拟环境。</p>
<h1 id="退出「virtualenv」环境"><a href="#退出「virtualenv」环境" class="headerlink" title="退出「virtualenv」环境"></a>退出「virtualenv」环境</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">deactivate</div></pre></td></tr></table></figure>
<p>退出成功后，命令提示符(<strong><code>&lt;env_name&gt;</code></strong>)前缀消失，此时就回到了正常的系统环境。</p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> virtualenv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[终端复用工具---「tmux」的安装及使用]]></title>
      <url>/2017/08/09/tmux-using-tutorial/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong><code>tmux</code></strong> 是一个优秀的终端复用软件，即使非正常掉线，也能保证当前的任务运行，这一点对于远程 <strong><code>ssh</code></strong> 访问特别有用，网络不好的情况下仍然能保证工作现场不丢失! <strong><code>tmux</code></strong>  完全使用键盘控制窗口，实现窗口的切换。<br><a id="more"></a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="在「Mac-OS」中安装"><a href="#在「Mac-OS」中安装" class="headerlink" title="在「Mac OS」中安装"></a>在「Mac OS」中安装</h2><h3 id="安装「Homebrew」"><a href="#安装「Homebrew」" class="headerlink" title="安装「Homebrew」"></a>安装「Homebrew」</h3><p>如果没有 <strong><code>homebrew</code></strong> ，先安装 <strong><code>homebrew</code></strong> ，如果已经安装，则跳过此步。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure></p>
<h3 id="安装「Tmux」"><a href="#安装「Tmux」" class="headerlink" title="安装「Tmux」"></a>安装「Tmux」</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install tmux</div></pre></td></tr></table></figure>
<h3 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h3><p>通过如下命令查看 <strong><code>tmux</code></strong> 的版本号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux -V</div></pre></td></tr></table></figure></p>
<p>当前安装版本为 <strong><code>2.6</code></strong>，则终端显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux 2.6</div></pre></td></tr></table></figure></p>
<h2 id="在「Ubuntu」中安装"><a href="#在「Ubuntu」中安装" class="headerlink" title="在「Ubuntu」中安装"></a>在「Ubuntu」中安装</h2><p>在终端输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install tmux</div></pre></td></tr></table></figure></p>
<h1 id="「Tmux」的配置文件"><a href="#「Tmux」的配置文件" class="headerlink" title="「Tmux」的配置文件"></a>「Tmux」的配置文件</h1><p><strong><code>tmux</code></strong> 的配置文件为 <strong><code>~/.tmux.conf</code></strong> ，每当开启一个新的会话时，<strong><code>tmux</code></strong>  都会先读取这个文件。本人使用的配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># 状态栏</div><div class="line"># 颜色</div><div class="line">set -g status-bg black</div><div class="line">set -g status-fg white</div><div class="line"></div><div class="line"># 对齐方式</div><div class="line">set-option -g status-justify centre</div><div class="line"></div><div class="line"># 左下角</div><div class="line">set-option -g status-left &apos;#[bg=black,fg=green][#[fg=cyan]#S#[fg=green]]&apos;</div><div class="line">set-option -g status-left-length 20</div><div class="line"></div><div class="line"># 窗口列表</div><div class="line">setw -g automatic-rename on</div><div class="line">set-window-option -g window-status-format &apos;#[dim]#I:#[default]#W#[fg=grey,dim]&apos;</div><div class="line">set-window-option -g window-status-current-format &apos;#[fg=cyan,bold]#I#[fg=blue]:#[fg=cyan]#W#[fg=dim]&apos;</div><div class="line"></div><div class="line"># 右下角</div><div class="line">set -g status-right &apos;#[fg=green][#[fg=cyan]%Y-%m-%d#[fg=green]]&apos;</div></pre></td></tr></table></figure>
<h1 id="「Tmux」的快捷键前缀-Prefix"><a href="#「Tmux」的快捷键前缀-Prefix" class="headerlink" title="「Tmux」的快捷键前缀(Prefix)"></a>「Tmux」的快捷键前缀(Prefix)</h1><p>为了使自身的快捷键和其他软件的快捷键互不干扰， <strong><code>tmux</code></strong> 提供了一个快捷键前缀(<strong><code>Prefix</code></strong>)，默认是组合键 <strong><code>Ctrl-b</code></strong>（同时按下 <strong><code>Ctrl</code></strong> 键和 <strong><code>b</code></strong> 键）<br>当想要使用快捷键时，需要先按下快捷键前缀，然后再按下快捷键，以下把前缀按键称为 <strong><code>Prefix</code></strong>。</p>
<p>下面介绍一下 <strong><code>tmux</code></strong> 的三个核心概念，会话(<strong><code>session</code></strong>)、窗口(<strong><code>window</code></strong>)和窗格(<strong><code>pane</code></strong>)及其基本用法。</p>
<h1 id="会话「session」"><a href="#会话「session」" class="headerlink" title="会话「session」"></a>会话「session」</h1><h2 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h2><p>创建一个新的会话，只需要在终端运行如下的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux new -s &lt;session_name&gt; -n &lt;window_name&gt;</div></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<blockquote>
<p><strong><code>-s</code></strong> 参数表示会话名称，如果不加 <strong><code>-s</code></strong> 参数，那么 <strong><code>tmux</code></strong> 默认会新建一个以数字(下标从 <strong><code>0</code></strong> 开始)命名的会话，并默认打开一个窗口。<br><strong><code>-n</code></strong> 参数表示默认打开的窗口的名称</p>
</blockquote>
<h2 id="重命名session"><a href="#重命名session" class="headerlink" title="重命名session"></a>重命名session</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + $ : 重命名当前的会话</div></pre></td></tr></table></figure>
<h2 id="断开session"><a href="#断开session" class="headerlink" title="断开session"></a>断开session</h2><p>想要暂时从 <strong><code>tmux</code></strong> 暂时分离，回到终端环境时，可以通过如下快捷键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + d : 断开当前的会话</div></pre></td></tr></table></figure></p>
<p>注意，即使是 <strong><code>detach</code></strong> 的状态，<strong><code>tmux</code></strong> 中在运行的程序还会继续运行</p>
<h2 id="回到session"><a href="#回到session" class="headerlink" title="回到session"></a>回到session</h2><p>想要回到 <strong><code>session</code></strong> 时，只需执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux attach -t &lt;session_name&gt;</div></pre></td></tr></table></figure></p>
<h2 id="列出session"><a href="#列出session" class="headerlink" title="列出session"></a>列出session</h2><p>在终端下，运行如下命令列出当前有多少个会话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux ls</div></pre></td></tr></table></figure></p>
<p>在会话中列出当前有多少个会话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + s : 列出所有会话</div></pre></td></tr></table></figure></p>
<h2 id="关闭session"><a href="#关闭session" class="headerlink" title="关闭session"></a>关闭session</h2><p>在终端下，要真正关闭一个会话，可以运行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux kill-session -t &lt;session_name&gt;</div></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<blockquote>
<p><strong><code>-t</code></strong> 参数表示会话名称。</p>
</blockquote>
<h1 id="窗口「window」"><a href="#窗口「window」" class="headerlink" title="窗口「window」"></a>窗口「window」</h1><p>如果说会话是个不可见的东西，那么窗口就是我们输入、执行命令的地方。一个会话 可以包含多个会话。</p>
<h2 id="创建window"><a href="#创建window" class="headerlink" title="创建window"></a>创建window</h2><p>在创建会话的时候默认会创建一个以 <strong><code>数字下标+bash</code></strong> 命名的窗口，并且名称随着 <strong><code>bash</code></strong> 中执行的不同命令而变化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + c : 创建一个新窗口</div></pre></td></tr></table></figure></p>
<h2 id="重命名window"><a href="#重命名window" class="headerlink" title="重命名window"></a>重命名window</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + , : 重命名当前窗口</div></pre></td></tr></table></figure>
<h2 id="切换window"><a href="#切换window" class="headerlink" title="切换window"></a>切换window</h2><p>同一个会话下的多个window之间切换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Prefix + p: 切换到上一个窗口。 </div><div class="line">Prefix + n: 切换到下一个窗口 。 </div><div class="line">Prefix + 0: 切换到0号window，依次类推，1、2、3... </div><div class="line">Prefix + w: 列出全部窗口，通过上、下键选择要进入的窗口，按回车键即可进入所选择的窗口中。</div></pre></td></tr></table></figure></p>
<h2 id="关闭window"><a href="#关闭window" class="headerlink" title="关闭window"></a>关闭window</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + &amp; : 关闭当前窗口。</div></pre></td></tr></table></figure>
<h1 id="窗格「pane」"><a href="#窗格「pane」" class="headerlink" title="窗格「pane」"></a>窗格「pane」</h1><p>一个窗口可以切割成多个窗格，也就是所谓的分屏。</p>
<h2 id="创建pane"><a href="#创建pane" class="headerlink" title="创建pane"></a>创建pane</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prefix + % : 垂直分屏，用一条垂线把当前窗口分成左右两屏。 </div><div class="line">Prefix + &quot; : 水平分屏，用一条水平线把当前窗口分成上下两屏。</div></pre></td></tr></table></figure>
<h2 id="切换pane"><a href="#切换pane" class="headerlink" title="切换pane"></a>切换pane</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Prefix + o : 依次切换当前窗口下的各个窗格。 </div><div class="line">Prefix + Up|Down|Left|Right : 根据按箭方向选择切换到某个窗格。 </div><div class="line">Prefix + Space(空格键): 对当前窗口下的所有窗格重新排列布局，每按一次，换一种样式。 </div><div class="line">Prefix + z : 最大化当前窗格。再按一次后恢复。</div></pre></td></tr></table></figure>
<h2 id="关闭pane"><a href="#关闭pane" class="headerlink" title="关闭pane"></a>关闭pane</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + x : 关闭当前使用中的窗格。</div></pre></td></tr></table></figure>
<h2 id="其他pane快捷键"><a href="#其他pane快捷键" class="headerlink" title="其他pane快捷键"></a>其他pane快捷键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Prefix + q : 显示窗格的编号</div><div class="line">Prefix + &#125; : 与下一个窗格交换位置</div><div class="line">Prefix + &#123; : 与上一个窗格交换位置</div><div class="line">Prefix + ! : 在新窗口中显示当前窗格</div><div class="line">Prefix + t : 在当前窗格显示时间</div></pre></td></tr></table></figure>
<h1 id="滚屏"><a href="#滚屏" class="headerlink" title="滚屏"></a>滚屏</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Prefix + [ : 滚屏</div></pre></td></tr></table></figure>
<p>滚屏要进入 <strong><code>copy-mode</code></strong>，然后就可以用上下键来滚动屏幕，配置了 <strong><code>vi</code></strong> 快捷键模式，就可以像操作 <strong><code>vi</code></strong> 一样来滚动屏幕，非常的方便。 退出直接回车键或 <strong><code>q</code></strong>键即可退出</p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux, tmux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git常用命令教程]]></title>
      <url>/2017/08/05/git-command-tutorial/</url>
      <content type="html"><![CDATA[<h1 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h1><h2 id="Git-介绍"><a href="#Git-介绍" class="headerlink" title="Git 介绍"></a>Git 介绍</h2><p><a href="https://git-scm.com/" target="_blank" rel="external">Git</a> 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<code>Git</code>的读音为/gɪt/。<code>Git</code> 是 <code>Linus Torvalds</code> 为了帮助管理 <code>Linux</code> 内核开发而开发的一个开放源码的版本控制软件。</p>
<h2 id="什么文件可以被-Git-管理"><a href="#什么文件可以被-Git-管理" class="headerlink" title="什么文件可以被 Git 管理?"></a>什么文件可以被 Git 管理?</h2><p>文本文件(.txt)，脚本文件(.py等)，各种基于文本信息的文件.</p>
<h2 id="什么文件不能被-Git-管理"><a href="#什么文件不能被-Git-管理" class="headerlink" title="什么文件不能被 Git 管理?"></a>什么文件不能被 Git 管理?</h2><p>图片文件(.jpg等)，PDF(.pdf)，MS Word(.doc)，MS Power Point(.ppt)，MS Excel(.xls)等。<br><a id="more"></a></p>
<h2 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h2><h3 id="Git-直接记录快照，而非差异比较"><a href="#Git-直接记录快照，而非差异比较" class="headerlink" title="Git 直接记录快照，而非差异比较"></a><code>Git</code> 直接记录快照，而非差异比较</h3><p><code>Git</code> 和其它版本控制系统（包括 <code>Subversion</code> 等）的主要差别在于 <code>Git</code> 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 这类系统（<code>CVS</code>、<code>Subversion</code>、<code>Perforce</code>、<code>Bazaar</code> 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。<br><code>Git</code> 不按照以上方式对待或保存数据。 反之，<code>Git</code> 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 <code>Git</code> 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，<code>Git</code> 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 <code>Git</code> 对待数据更像是一个「快照流」。<br>这是 <code>Git</code> 与几乎所有其它版本控制系统的重要区别。 因此 <code>Git</code> 重新考虑了以前每一代版本控制系统延续下来的诸多方面。<code>Git</code> 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 <code>VCS</code>。</p>
<h3 id="Git-不需要联网就能工作"><a href="#Git-不需要联网就能工作" class="headerlink" title="Git 不需要联网就能工作"></a><code>Git</code> 不需要联网就能工作</h3><p>在 <code>Git</code> 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息，由于本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。而其他集中式版本控制系统(例如 <code>SVN</code>等)，必须联网才能工作， 所有操作都有网络延时开销。</p>
<h3 id="Git-保证完整性"><a href="#Git-保证完整性" class="headerlink" title="Git 保证完整性"></a><code>Git</code> 保证完整性</h3><p><code>Git</code> 的内容完整性要优于其他集中式版本控制系统(例如 <code>SVN</code>等)。<code>Git</code> 中所有数据在存储前都计算校验和，然后以校验和来引用。这个功能建构在 <code>Git</code> 底层，是构成 <code>Git</code> 哲学不可或缺的部分。 若在传送过程中丢失信息或损坏文件，<code>Git</code> 就能发现。<code>Git</code> 用以计算校验和的机制叫做 <code>SHA-1</code> 哈希散列。 这是一个由40个十六进制字符(<code>0-9</code> 和 <code>a-f</code>)组成字符串，基于 <code>Git</code> 中文件的内容或目录结构计算出来。 <code>SHA-1</code> 哈希看起来是这样：<code>24b9da6552252987aa493b52f8696cd6d3b00373</code>，<code>Git</code> 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，<code>Git</code>  数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<h3 id="Git-一般只添加数据"><a href="#Git-一般只添加数据" class="headerlink" title="Git 一般只添加数据"></a><code>Git</code> 一般只添加数据</h3><p><code>Git</code> 操作，几乎只往 <code>Git</code> 数据库中增加数据。 很难让 <code>Git</code> 执行任何不可逆操作，或者让它以任何方式清除数据。 同别的 <code>VCS</code> 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 <code>Git</code> 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。这使得在使用 <code>Git</code> 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。</p>
<h1 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h1><p>最早 <code>Git</code> 是在 <code>Linux</code> 上开发的，很长一段时间内，<code>Git</code> 也只能在 <code>Linux</code> 和 <code>Unix</code> 系统上跑。目前，<code>Git</code> 已经可以在 <code>Linux</code>、<code>Unix</code>、<code>Mac</code> 和 <code>Windows</code> 几大平台上运行。详细的安装说明请前往<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" target="_blank" rel="external"> Git官网安装说明 </a>查看， <code>Git</code> 在每种系统上的安装方式各不相同，安装步骤分别如下:</p>
<h2 id="Linux平台上安装"><a href="#Linux平台上安装" class="headerlink" title="Linux平台上安装"></a>Linux平台上安装</h2><p>打开 <code>terminal</code>，可以用下面的命令安装：</p>
<h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> apt-get install git-all</div></pre></td></tr></table></figure>
<p>使用 <code>git --version</code> 查看是否安装成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git --version</div><div class="line">git version 2.7.4</div></pre></td></tr></table></figure></p>
<h3 id="Centos-RedHat"><a href="#Centos-RedHat" class="headerlink" title="Centos/RedHat"></a>Centos/RedHat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> yum -y install git-all</div></pre></td></tr></table></figure>
<p>使用 <code>git --version</code> 查看是否安装成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git --version</div><div class="line">git version 1.7.1</div></pre></td></tr></table></figure></p>
<h2 id="Mac-平台上安装"><a href="#Mac-平台上安装" class="headerlink" title="Mac 平台上安装"></a>Mac 平台上安装</h2><p>1、先下载 <code>.dmg</code> 安装包，下载地址为：<a href="https://git-scm.com/download/mac" target="_blank" rel="external">https://git-scm.com/download/mac</a> ，点击下载到本地，下载文件例如：<code>git-2.14.1-intel-universal-mavericks.dmg</code><br>2、双击安装包进行安装即可<br>3、使用 <code>git --version</code> 查看是否安装成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git --version</div><div class="line">git version 2.14.1</div></pre></td></tr></table></figure></p>
<h2 id="Windows-平台上安装"><a href="#Windows-平台上安装" class="headerlink" title="Windows 平台上安装"></a>Windows 平台上安装</h2><p>1、先下载 <code>.exe</code> 安装包，下载地址为：<a href="https://git-scm.com/download/win" target="_blank" rel="external">https://git-scm.com/download/win</a> ，选择适合当前系统的版本，点击下载到本地<br>2、双击安装包进行安装即可<br>3、在开始菜单里找到<code>Git</code>-&gt;<code>Git Bash</code>，会弹出 <code>Git</code> 命令窗口，使用 <code>git --version</code> 查看是否安装成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git version</div><div class="line">git version 2.14.2.windows.1</div></pre></td></tr></table></figure></p>
<h1 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h1><p>安装 <code>Git</code> 后，每台计算机上只需要进行一次配置，程序升级时会保留配置信息。你可以在任何时候再次通过运行命令来修改它们。<br><code>Git</code> 自带一个 <code>git config</code> 的工具，专门用来配置或读取相应的工作环境变量。这些变量存储在三个不同的位置：</p>
<ul>
<li><code>/etc/gitconfig</code> 文件： 包含系统上每一个用户及他们仓库的通用配置，如果使用带有 <code>--system</code> 选项的 <code>git config</code> 时，它会从此文件读写配置变量。</li>
<li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户，可以传递 <code>--global</code> 选项让 <code>Git</code> 读写此文件。</li>
<li>当前使用仓库的 <code>Git</code> 目录中的 <code>config</code> 文件(就是 <code>.git/config</code>)：针对该仓库。</li>
</ul>
<p>每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。</p>
<p>在 <code>Windows</code> 系统中，<code>Git</code> 会查找 <code>$HOME</code> 目录下（一般情况下是 <code>C:\Users\$USER</code>）的 <code>.gitconfig</code> 文件。 <code>Git</code> 同样也会寻找 <code>/etc/gitconfig</code> 文件，但只限于 <code>MSys</code> 的根目录下，即安装 <code>Git</code> 时所选的目标位置。</p>
<h2 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h2><p>当安装完 <code>Git</code> 应该做的第一件事就是设置个人的「用户名称」与「邮件地址」。 这样做很重要，因为每一个 <code>Git</code> 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git config --global user.name lichengjin</div><div class="line"><span class="meta">$</span> git config --global user.email lichengjin606@gmail.com</div></pre></td></tr></table></figure></p>
<p>再次强调，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，<code>Git</code> 都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code>选项的命令来配置，新的设定保存在当前项目的 <code>.git/config</code> 文件里。</p>
<h2 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h2><p>要检查已有的配置信息，可以使用 <code>git config --list</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git config --list</div><div class="line">user.name=lichengjin</div><div class="line">user.email=lichengjin606@gmail.com</div></pre></td></tr></table></figure></p>
<p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 <code>/etc/gitconfig</code> 和 <code>~/.gitconfig</code>），不过最终 <code>Git</code> 实际采用的是最后一个。<br>这些配置我们也可以在 <code>~/.gitconfig</code> 或 <code>/etc/gitconfi</code> 看到，如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> vim ~/.gitconfig</div></pre></td></tr></table></figure></p>
<p>显示内容如下所示：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[user]</div><div class="line">    	name = lichengjin</div><div class="line">    	email = lichengjin606@gmail.<span class="keyword">com</span></div></pre></td></tr></table></figure></p>
<p>你可以通过输入 <code>git config &lt;key&gt;</code> 来检查 <code>Git</code>的某一项配置，例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git config user.name</div><div class="line">lichengjin</div></pre></td></tr></table></figure></p>
<h1 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h1><p><code>Git</code> 的工作流程如下：</p>
<ol>
<li>克隆 <code>Git</code> 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>
</ol>
<p>下图展示了 <code>Git</code> 的工作流程，图片来自<a href="http://www.runoob.com/git/git-workflow.html" target="_blank" rel="external">菜鸟教程</a>：<br><img src="/images/git/git_process.jpg" alt="Git 工作流程图"></p>
<h1 id="Git-工作区，暂存区和版本库"><a href="#Git-工作区，暂存区和版本库" class="headerlink" title="Git 工作区，暂存区和版本库"></a>Git 工作区，暂存区和版本库</h1><p>工作区：就是你在电脑里能看到的目录。是对项目的某个版本独立提取出来的内容。 这些从 <code>Git</code> 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。<br>暂存区：英文叫<code>stage</code>， 或<code>index</code>。是一个文件，一般存放在 <code>.git/index</code> 中，保存了下次将提交的文件列表信息，有时候也被称作索引( <code>index</code> )。<br>版本库：版本库又名仓库，英文名<code>repository</code>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被 <code>Git</code> 管理起来，每个文件的修改、删除，<code>Git</code> 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原。工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 <code>Git</code> 的版本库，是 <code>Git</code> 用来保存项目的元数据和对象数据库的地方。 这是 <code>Git</code> 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。<br>下面这个图展示了「工作区」、「暂存区」和「版本库」之间的关系，图片来自<a href="http://www.runoob.com/git/git-workspace-index-repo.html" target="_blank" rel="external">菜鸟教程</a>：<br><img src="/images/git/git_work_stage_respository.jpg" alt="工作区、暂存区和版本库之间的关系"><br>图中左侧为「工作区」，右侧为「版本库」。在「版本库」中标记为 <code>index</code> 的区域是「暂存区」(<code>stage</code>，<code>index</code>)，标记为 <code>master</code> 的是 <code>master</code> 分支所代表的目录树。<br>图中我们可以看出此时 <code>HEAD</code> 实际是指向 <code>master</code> 分支的一个「游标」。所以图示的命令中出现 <code>HEAD</code> 的地方可以用 <code>master</code> 来替换。<br>图中的 <code>objects</code> 标识的区域为 <code>Git</code> 的「对象库」，实际位于 <code>.git/objects</code> 目录下，里面包含了创建的各种对象及内容。<br>当对「工作区」修改或新增的文件执行 <code>git add</code> 命令时，「暂存区」的目录树被更新，同时「工作区」修改或新增的文件内容被写入到「对象库」中的一个新的对象中，而该对象的 <code>ID</code> 被记录在暂存区的文件索引中。<br>当执行提交操作 <code>git commit</code> 时，「暂存区」的目录树写到「版本库」中，<code>master</code> 分支会做相应的更新。即 <code>master</code> 指向的目录树就是提交时「暂存区」的目录树。<br>当执行 <code>git reset HEAD</code> 命令时，「暂存区」的目录树会被重写，被 <code>master</code> 分支指向的目录树所替换，但是「工作区」不受影响。<br>当执行 <code>git rm --cached &lt;file&gt;</code> 命令时，会直接从「暂存区」删除文件，「工作区」则不做出改变。<br>当执行 <code>git checkout .</code> 或者 <code>git checkout -- &lt;file&gt;</code> 命令时，会用「暂存区」全部或指定的文件替换「工作区」的文件。这个操作很危险，会清除「工作区」中未添加到「暂存区」的改动。<br>当执行 <code>git checkout HEAD .</code> 或者 <code>git checkout HEAD &lt;file&gt;</code> 命令时，会用 <code>HEAD</code> 指向的 <code>master</code> 分支中的全部或者部分文件替换「暂存区」和以及「工作区」中的文件。这个命令也是极具危险性的，因为不但会清除「工作区」中未提交的改动，也会清除「暂存区」中未提交的改动。</p>
<h1 id="获取版本库"><a href="#获取版本库" class="headerlink" title="获取版本库"></a>获取版本库</h1><h2 id="创建新的版本库"><a href="#创建新的版本库" class="headerlink" title="创建新的版本库"></a>创建新的版本库</h2><p>1、 选择一个合适的地方，创建一个空目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> mkdir git_tutorial</div><div class="line"><span class="meta">$</span> cd git_tutorial</div><div class="line"><span class="meta">$</span> pwd</div><div class="line">/Users/lichengjin/workspace/git_tutorial</div></pre></td></tr></table></figure>
<p>2、 通过 <code>git init</code> 命令把这个目录变成 <code>Git</code> 可以管理的仓库:<br>注：如果打算使用 <code>Git</code> 来对现有的项目进行管理，只需要进入该项目目录并输入<code>git init</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git init</div><div class="line">Initialized empty Git repository in /Users/lichengjin/workspace/git_tutorial/.git/</div></pre></td></tr></table></figure>
<p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 <code>Git</code> 仓库中所有的必须文件，这些文件是 <code>Git</code> 仓库的骨干，是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。<br>如果你没有看到 <code>.git</code> 目录，那是因为这个目录默认是隐藏的，用 <code>ls -a</code> 命令查看即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ls -a</div><div class="line">.    ..   .git</div></pre></td></tr></table></figure></p>
<h2 id="克隆现有的版本库"><a href="#克隆现有的版本库" class="headerlink" title="克隆现有的版本库"></a>克隆现有的版本库</h2><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 <code>git clone</code> 命令。 如果你对其它的 <code>VCS</code> 系统（比如说 <code>Subversion</code> ）很熟悉，请留心一下你所使用的命令是 <code>clone</code> 而不是 <code>checkout</code>。 这是 <code>Git</code> 区别于其它版本控制系统的一个重要特性，<code>Git</code> 克隆的是该 <code>Git</code> 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 <code>git clone</code> 命令的时候，默认配置下远程 <code>Git</code> 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库(虽然可能会丢失某些服务器端的挂钩设置，但是所有版本的数据仍在)。</p>
<p>克隆仓库的命令格式：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone &lt;repo&gt;</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/ChengjinLi/machine_learning.git</div></pre></td></tr></table></figure></p>
<p>如果我们需要克隆到指定的目录，可以使用以下命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone &lt;repo&gt; &lt;directory&gt;</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/ChengjinLi/machine_learning.git mj_machine_learning</div></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li>repo：Git 仓库。</li>
<li>directory：本地目录。</li>
</ul>
<p><code>Git</code> 支持多种数据传输协议。 上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 <code>SSH</code> 传输协议。</p>
<h1 id="Git-文件生命周期"><a href="#Git-文件生命周期" class="headerlink" title="Git 文件生命周期"></a>Git 文件生命周期</h1><p>请记住，「工作目录」下的每一个文件都不外乎这两种状态：「已跟踪」或「未跟踪」。「已跟踪」的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于「未修改」，「已修改」或「已放入暂存区」。 「工作目录」中除「已跟踪」文件以外的所有其它文件都属于「未跟踪」文件，它们既不存在于上次快照的记录中，也没有放入「暂存区」。 初次克隆某个仓库的时候，「工作目录」中的所有文件都属于「已跟踪」文件，并处于「未修改」状态。编辑过某些文件之后，由于自上次提交后你对它们做了修改，<code>Git</code> 将它们标记为「已修改」文件。 我们逐步将这些修改过的文件放入「暂存区」，然后提交所有暂存了的修改，如此反复。<br>使用 <code>Git</code> 时文件的生命周期如下：<br><img src="/images/git/git_life_cycle.jpg" alt="Git 文件生命周期"></p>
<h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><p><strong><code>git add &lt;file_name&gt;/&lt;dir_name&gt;</code></strong><br>将文件添加到暂存区，参数可以是指定路径的文件名或目录的名字，也可以使用 glob 模式。</p>
<p><strong><code>git status</code></strong><br>查看项目的当前状态，输出详细内容<br><strong><code>git status --short</code></strong> 或 <strong><code>git status -s</code></strong><br>查看项目的当前状态，以简短的结果输出<br>状态说明：</p>
<ul>
<li>?? 未跟踪的文件</li>
<li>M：修改过的文件，出现在靠左边的<code>M</code>表示该文件被修改了并放入了暂存区，出现在右边的<code>M</code>表示该文件被修改了但是还没放入暂存区，</li>
<li>A：新添加到暂存区的文件</li>
<li>D：已删除(deleted)</li>
<li>R：重命名(renamed)</li>
<li>C：已拷贝(copied)</li>
<li>U：已更新但为合并(updated but unmerged)</li>
</ul>
<p><strong><code>git diff</code></strong><br>查看尚未 <code>add</code> 的所有文件的改动和上个已经 <code>commit</code>的文件的不同<br><strong><code>git diff &lt;file_name&gt;</code></strong><br>查看尚未 <code>add</code> 的 <code>&lt;file_name&gt;</code> 文件的改动和上个已经 <code>commit</code>的文件的不同<br><strong><code>git diff --cached</code></strong><br>查看已经 <code>add</code> 的文件的改动<br><strong><code>git diff HEAD</code></strong><br>查看已 <code>add</code> 的与未 <code>add</code> 的所有改动<br><strong><code>git diff --stat</code></strong><br>显示摘要而非整个<code>diff</code></p>
<p><strong><code>git commit -m &quot;message&quot;</code></strong><br>将暂存区的文件提交到版本库，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，最好是有意义的，方便从历史记录找到改动记录。<br><strong><code>git commit --amend --no-edit</code></strong><br>将本次改动直接合并到上一个 <code>commit</code> 中<br><strong><code>git commit -am &quot;message&quot;</code></strong><br>跳过使用暂存区的方式，自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</p>
<p><strong><code>git rm &lt;file_name&gt;/&lt;dir_name&gt;</code></strong><br>将文件从暂存区域移除，参数可以是指定路径的文件名或目录的名字，也可以使用 glob 模式。<br><strong><code>git rm --cached &lt;file_name&gt;/&lt;dir_name&gt;</code></strong><br>将文件从 <code>Git</code> 仓库中删除，但仍然希望保留在当前工作目录中，参数可以是指定路径的文件名或目录的名字，也可以使用 glob 模式。</p>
<p><strong><code>git mv &lt;file_from&gt; &lt;file_to&gt;</code></strong><br>将 <code>Git</code> 中的 <code>&lt;file_from&gt;</code> 重命名为 <code>&lt;file_to&gt;</code></p>
<p><strong><code>git log</code></strong><br>查看历史提交记录，显示从最近到最远的提交日志<br><strong><code>git log --oneline</code></strong><br>一行显示一次提交<br><strong><code>git log --oneline --graph</code></strong><br>查看历史中什么时候出现了分支、合并，开启了拓扑图选项<br><strong><code>git log --author=&lt;user_name&gt;</code></strong><br>查找指定用户 <code>&lt;user_name&gt;</code> 的提交日志</p>
<p><strong><code>git reflog</code></strong><br>查看历史命令记录，显示从最近到最远的日志</p>
<p><strong><code>git reset HEAD</code></strong><br>取消已缓存的内容，即取消之前 <code>git add</code> 添加的内容<br>在 <code>Git</code> 中，用 <code>HEAD</code> 表示当前版本，上一个版本就是 <code>HEAD^</code> ，上上一个版本就是 <code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成 <code>HEAD~100</code>。<br><strong><code>git reset &lt;file_name&gt;</code></strong><br>取消已缓存的<code>&lt;file_name&gt;</code>，即取消之前 <code>git add</code> 添加的内容<br><strong><code>git reset --hard &lt;commit_id&gt;</code></strong><br>回退到指定 <code>&lt;commit_id&gt;</code> 版本，<code>&lt;commit_id&gt;</code>没必要写全，前位(例如前7位)就可以了，<code>Git</code> 会自动去找，当然也不能只写前一两位，因为 <code>Git</code> 可能会找到多个版本号，就无法确定是哪一个了。</p>
<p><strong><code>git checkout &lt;commid_id&gt; -- &lt;file_name&gt;</code></strong><br>将 <code>&lt;file_name&gt;</code> 回退到 <code>&lt;commid_id&gt;</code> 的版本<br><strong><code>git checkout &lt;branch_name&gt;</code></strong><br>将 <code>HEAD</code> 从当前分支切换到 <code>&lt;branch_name&gt;</code> 分支<br><strong><code>git checkout -b &lt;branch_name&gt;</code></strong><br>创建 <code>&lt;branch_name&gt;</code> 分支，并切换到新建的分支</p>
<p><strong><code>git branch</code></strong><br>查看当前分支，<code>*</code>代表了当前 <code>HEAD</code> 所在的分支<br><strong><code>git branch &lt;branch_name&gt;</code></strong><br>创建 <code>&lt;branch_name&gt;</code> 分支</p>
<p><strong><code>git merge &lt;branch_name&gt;</code></strong><br>将 <code>&lt;branch_name&gt;</code> 合并到当前分支，<code>Git</code> 会采用默认的 <code>Fast forward</code> 格式进行合并，这次合并操作不会有 <code>commit</code> 信息，<code>log</code> 中也不会有分支的图案。<br><strong><code>git merge --no-diff -m &quot;message&quot; &lt;branch_name&gt;</code></strong><br>采取 <code>--no-ff</code> 这种方式保留合并的 <code>commit</code> 信息。</p>
<h1 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h1><p>一般我们总会有些文件无需纳入 <code>Git</code> 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为<code>.gitignore</code> 的文件，列出要忽略的文件模式。要养成一开始就设置好 <code>.gitignore</code> 文件的习惯，以免将来误提交这类无用的文件。<br>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>＃</code> 开头的行都会被 <code>Git</code> 忽略。</li>
<li>可以使用标准的 <code>glob</code> 模式匹配。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
<p>所谓的 <code>glob</code> 模式是指 <code>shell</code> 所使用的简化了的正则表达式。 星号<code>*</code>匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 <code>a</code>，要么匹配一个 <code>b</code>，要么匹配一个 <code>c</code>）；问号<code>?</code>只匹配一个任意字符；如果在方括号中使用短划线<code>-</code>分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有<code>0</code>到<code>9</code>的数字）。 使用两个星号<code>*</code>表示匹配任意中间目录，比如<code>a/**/z</code> 可以匹配 <code>a/z</code>, <code>a/b/z</code> 或 <code>a/b/c/z</code>等。<code>GitHub</code> 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表，你可以在 <a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a> 找到它.</p>
<h1 id="Github-使用"><a href="#Github-使用" class="headerlink" title="Github 使用"></a>Github 使用</h1><p><a href="https://github.com/" target="_blank" rel="external">Github</a> 是一个大家都积极贡献的地方， 你可以和各种人合作创作，也是开源的天堂， 只要你愿意, 任何人都能下载, 或修改你的杰作。<br>在<code>Github</code> 上注册一个账户<br>然后添加一个 <code>online</code> 版本库 <code>repository</code><br>连接本地版本库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add [alias] [url]</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git remote add origin https://github.com/ChengjinLi/machine_learning.git</div><div class="line"><span class="meta">$</span> git push -u origin master     # 推送本地 master 去 origin</div></pre></td></tr></table></figure></p>
<p>在执行 <code>commit</code> 之后，可以执行 <code>git push -u origin master</code> 将本地修改提交到 <code>Github</code></p>
<p>要查看当前配置有哪些远程仓库，可以用命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git remote</div><div class="line">origin</div></pre></td></tr></table></figure></p>
<p>执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git remote -v</div><div class="line">origin	https://github.com/ChengjinLi/machine_learning.git (fetch)</div><div class="line">origin	https://github.com/ChengjinLi/machine_learning.git (push)</div></pre></td></tr></table></figure></p>
<p>删除别名为 <code>&lt;alias&gt;</code> 的远程仓库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git remote rm &lt;alias&gt;</div></pre></td></tr></table></figure></p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>Git 官网： <a href="https://git-scm.com/" target="_blank" rel="external">https://git-scm.com/</a><br>Git 完整命令手册地址： <a href="http://git-scm.com/docs" target="_blank" rel="external">http://git-scm.com/docs</a><br>Pro Git book： <a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">https://git-scm.com/book/zh/v2</a><br>廖雪峰Git教程：<br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a><br>菜鸟Git教程： <a href="http://www.runoob.com/git/git-tutorial.html" target="_blank" rel="external">http://www.runoob.com/git/git-tutorial.html</a><br>Github 官网： <a href="https://github.com/" target="_blank" rel="external">https://github.com/</a></p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vim常用命令教程]]></title>
      <url>/2017/08/04/vim-command-tutorial/</url>
      <content type="html"><![CDATA[<p><code>vim</code> 的配置文件在根目录的 <code>.vimrc</code> 文件中，如果没有，自己创建一个。<br><a id="more"></a><br>打开 <code>.vimrc</code> 文件，输入配置，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">set paste    &quot; 进入paste模型</div><div class="line">set number     &quot; 显示行号</div><div class="line">set tabstop=4     　&quot; 一个tab为4个空格长度</div><div class="line">set shiftwidth=4     &quot; 将换行自动缩进设置成4个空格</div><div class="line">set expandtab     &quot; 输入tab时自动将其转化为空格</div><div class="line">set sts=4     &quot; 敲入tab键时实际占有的列数</div><div class="line">set autoindent     &quot; 设置自动缩进</div><div class="line">set smartindent    &quot; 智能缩进</div><div class="line">set mouse=a    &quot; 鼠标可用</div><div class="line">syntax on     &quot; 语法高亮</div><div class="line">set hlsearch    &quot; 开启查找匹配的高亮显示, 简写set hls</div><div class="line">&quot; set nohlsearch     &quot; 关闭查找匹配的高亮显示, 简写set nohls</div><div class="line">set encoding=utf-8     &quot; 屏幕显示的编码</div><div class="line">set fileencoding=utf-8     &quot; 正在被编辑的文件的编码</div><div class="line">set fileencodings=ucs-bom,utf-8,cp936,gbk,gb2312</div><div class="line">set termencoding=utf-8</div><div class="line">set showmatch    &quot; 括号匹配  </div><div class="line">set ruler     &quot; 右下角显示光标状态行  </div><div class="line">set incsearch     &quot; 设置快速搜索  </div><div class="line">set foldenable     &quot; 开启代码折叠  </div><div class="line">set fdm=manual     &quot; 手动折叠 </div><div class="line">set foldmethod=syntax     &quot; 自动语法折叠  </div><div class="line">set modeline     &quot; 自动载入模式行</div><div class="line">set cursorline     &quot; 开启光亮光标行</div><div class="line">set cursorcolumn     &quot; 开启光亮光标列</div><div class="line"></div><div class="line">&quot; vundle 环境设置</div><div class="line">filetype off</div><div class="line">set rtp+=~/.vim/bundle/Vundle.vim</div><div class="line"> vundle 管理的插件列表必须位于 vundle#begin() 和 vundle#end() 之间</div><div class="line">call vundle#begin()</div><div class="line">Plugin &apos;altercation/vim-colors-solarized&apos;</div><div class="line">Plugin &apos;tomasr/molokai&apos;</div><div class="line">Plugin &apos;vim-scripts/phd&apos;</div><div class="line">Plugin &apos;Lokaltog/vim-powerline&apos;</div><div class="line">Plugin &apos;octol/vim-cpp-enhanced-highlight&apos;</div><div class="line">Plugin &apos;Raimondi/delimitMate&apos;</div><div class="line">Plugin &apos;scrooloose/nerdtree&apos;</div><div class="line">Plugin &apos;vim-scripts/indentpython.vim&apos;</div><div class="line">Plugin &apos;davidhalter/jedi-vim&apos;</div><div class="line">&quot;Plugin &apos;w0rp/ale&apos;</div><div class="line">Plugin &apos;Shougo/neocomplete.vim&apos;</div><div class="line">Plugin &apos;majutsushi/tagbar&apos;</div><div class="line">&quot; 插件列表结束</div><div class="line">call vundle#end()</div><div class="line">filetype plugin indent on</div><div class="line"></div><div class="line">map &lt;F3&gt; :nohlsearch&lt;CR&gt;    &quot; 绑定快捷键来去掉当前显示的高亮（一次性）</div><div class="line">:set pastetoggle=&lt;F10&gt;    &quot; 绑定快捷键来激活/取消 paste模式</div><div class="line">nnoremap &lt;silent&gt; &lt;F11&gt; :AV&lt;CR&gt; </div><div class="line">map &lt;F12&gt; :q&lt;CR&gt;    &quot; 绑定快捷键来退出当前vim编辑：</div></pre></td></tr></table></figure></p>
<p>设置说明：</p>
<p>set shiftwidth(简写：sw)</p>
<p>这个是用于程序中自动缩进所使用的空白长度。一般来说为了保持程序的美观，和下面的参数最好一致。同时它也是符号移位长度的制定者。</p>
<p>set tabstop(简写：ts)</p>
<p>定义tab所等同的空格长度，linux 内核代码建议每个tab占用8列，因为如果是其它值的话，可能引起文件在打印之类的场合中看起来很别扭。</p>
<p>set expandtab(简写：et)</p>
<p>输入tab时自动将其转化为空格，这样的话就不会一起混淆，不过毕竟制表符为8是最常用最普遍的设置，所以一般还是不要改。<br>举个例子，在多人一起开发项目时，为了使代码风格尽量保持一致，一般不允许在代码使用TAB符，而以4个空格代之。</p>
<p>set softtabstop(简写：sts)</p>
<p>敲入tab键时实际占有的列数。如果我们希望改变程序中的缩进怎么办？shiftwidth和tabstop不一样的话，你会发现程序比较难看的。这时候，softtabstop就起作用了。可以从vim的说明中看到，一旦设置了softtabstop的值时，你按下tab键，插入的是空格和tab制表符的混合，具体如何混合取决于你设定的softtabstop，举个例子，如果设定softtabstop=8, 那么按下tab键，插入的就是正常的一个制表符;如果设定 softtabstop=16,那么插入的就是两个制表符；如果softtabstop=12,那么插入的就是一个制表符加上4个空格；如果softtabstop=4呢？那么一开始，插入的就是4个空格，此时一旦你再按下一次tab，这次的四个空格就会和上次的四个空格组合起来变成一个制表符。换句话说，softtabstop是“逢8空格进1制表符”,前提是你tabstop=8。</p>
<p>set number(简写：nu)</p>
<p>显示行号</p>
<p>set nonumber(简写：nonu)</p>
<p>关闭行号显示</p>
<p>set ruler</p>
<p>设置在窗口右下角显示行号，与上面的好处是，节省空间</p>
<p>set autoindent(简写：ai)</p>
<p>设置自动缩进</p>
<p>syntax on</p>
<p>语法高亮</p>
<p>set smartindent </p>
<p>智能缩进</p>
<p>set encoding</p>
<p>屏幕显示的编码，目前大部分Linux系统已经将utf-8作为默认locale，encoding就应是utf-8以方便显示。该选项使用于缓冲的文本(你正在编辑的文件)，寄存器，Vim 脚本文件等等。你可以把 ‘encoding’ 选项当作是对 Vim 内部运行机制的设定。 </p>
<p>set fileencoding</p>
<p>正在被编辑的文件的编码，它也决定新文件的编码。如果为空，表示与encoding相同。如果与encoding不同，vi将会在保存和读取时做二者之间的转换。</p>
<p>set fileencodings</p>
<p>供vim尝试的编码列表，vi会逐个尝试每一项，如果没有发生错误，就设置当前的fileencoding为与该项相同的值。如果均失败，fileencoding将为空。</p>
<p>set termencoding</p>
<p>输出到客户终端（Term）采用的编码类型，默认空值，也就是输出到终端不进行编码转换。 </p>
<p>set showmatch</p>
<p>括号匹配  </p>
<p>set ruler</p>
<p>右下角显示光标状态行  </p>
<p>set incsearch</p>
<p>设置快速搜索  </p>
<p>set foldenable</p>
<p>开启代码折叠  </p>
<p>set fdm=manual</p>
<p>手动折叠 </p>
<p>set foldmethod=syntax</p>
<p>自动语法折叠  </p>
<p>set modeline</p>
<p>自动载入模式行</p>
<p>set ignorecase</p>
<p>大小写无关</p>
<p>set noignorecase</p>
<p>大小写敏感</p>
<p>set hlsearch</p>
<p>开启查找匹配的高亮显示, 简写set hls</p>
<p>set nohlsearch</p>
<p>关闭查找匹配的高亮显示, 简写set nohls  </p>
<p>:nohlsearch</p>
<p>去掉当前显示的高亮（一次性）</p>
<p>:set paste</p>
<p>进入paste模型,进入 paste 模式后，按 i 键进入插入模式，然后再粘帖，文本格式不会错乱了。但粘帖后还需要按 <esc> </esc></p>
<p>进入普通模式并执行如下命令结束 paste 模式：</p>
<p>:set nopaste</p>
<p>结束 paste 模式</p>
<p>:set pastetoggle=<f10\></f10\></p>
<p>paste有一个切换paste开关的选项，这就是pastetoggle。通过它可以绑定快捷键来激活/取消 paste模式</p>
<p>vim 的插件使用 vundle 管理：</p>
<p>安装 vundle：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</div></pre></td></tr></table></figure></p>
<p>安装插件，先找到其在 github.com 的地址，再将配置信息加入 .vimrc 中的call vundle#begin() 和 call vundle#end() 之间，如我的配置文件所示，Plugin ‘插件地址’ 即为添加插件，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plugin &apos;majutsushi/tagbar&apos;</div></pre></td></tr></table></figure></p>
<p>最后进入 vim 执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:PluginInstall</div></pre></td></tr></table></figure></p>
<p>便安装完成插件。</p>
<p>如需删除插件，只需将 Plugin ‘插件地址’ 删除或者注释掉，再进入 vim 执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:PluginClean</div></pre></td></tr></table></figure>
<p>便将插件删除。</p>
<p>如需升级插件，进入 vim 执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:PluginUpdate</div></pre></td></tr></table></figure></p>
<p>便完成升级。</p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[本地挂载服务器文件夹工具---「sshfs」的安装及使用]]></title>
      <url>/2017/08/03/sshfs-install-and-using-on-mac/</url>
      <content type="html"><![CDATA[<p>对于习惯在本地使用「<strong>IDE</strong>」工具进行编辑而不习惯在服务器上使用 「<strong>vim</strong>」 进行编辑的同学，下面介绍一个非常方便的在本地挂载服务器文件夹的工具 「<strong>sshfs</strong>」。下面介绍在「<strong>Mac</strong>」(系统版本：macOS Sierra 10.12.6)下的安装及使用方法：</p>
<h1 id="安装「sshfs」"><a href="#安装「sshfs」" class="headerlink" title="安装「sshfs」"></a>安装「<strong>sshfs</strong>」</h1><h2 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 <a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew</a></h2><a id="more"></a>
<p>先确定是否已经安装「<strong>Homebrew</strong>」，在命令行执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew -v</div></pre></td></tr></table></figure></p>
<p>输出示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Homebrew &gt;1.2.0 (no git repository)</div><div class="line">Homebrew/homebrew-core (git revision 9cf7; last commit 2017-09-22)</div></pre></td></tr></table></figure></p>
<p>如果没有安装，则执行如下命令进行安装，在命令行执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure></p>
<h2 id="安装-「sshfs」-的依赖-「osxfuse」"><a href="#安装-「sshfs」-的依赖-「osxfuse」" class="headerlink" title="安装 「sshfs」 的依赖 「osxfuse」"></a>安装 「<strong>sshfs</strong>」 的依赖 「<strong>osxfuse</strong>」</h2><p>执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install caskroom/cask/osxfuse</div></pre></td></tr></table></figure></p>
<h2 id="安装-「sshfs」"><a href="#安装-「sshfs」" class="headerlink" title="安装 「sshfs」"></a>安装 「<strong>sshfs</strong>」</h2><p>执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install sshfs</div></pre></td></tr></table></figure></p>
<h1 id="使用-「sshfs」-挂载"><a href="#使用-「sshfs」-挂载" class="headerlink" title="使用 「sshfs」 挂载"></a>使用 「<strong>sshfs</strong>」 挂载</h1><p>执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sshfs -C -o reconnect user@hostname:remote_dir local_dir</div></pre></td></tr></table></figure></p>
<p>参数说明如下：</p>
<ul>
<li>user: 远程连接用户名</li>
<li>hostname: 远程连接的主机名</li>
<li>remote_dir: 远程目录</li>
<li>local_dir: 本地目录</li>
</ul>
<h1 id="查看挂载情况"><a href="#查看挂载情况" class="headerlink" title="查看挂载情况"></a>查看挂载情况</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df -h local_dir</div></pre></td></tr></table></figure>
<h1 id="使用-「umount」-取消挂载"><a href="#使用-「umount」-取消挂载" class="headerlink" title="使用 「umount」 取消挂载"></a>使用 「<strong>umount</strong>」 取消挂载</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">umount local_dir</div></pre></td></tr></table></figure>
<h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><p>如过我们的Mac休眠或重启, 发现挂载的失败了, 进入目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls local_dir</div></pre></td></tr></table></figure></p>
<p>会提示如下类似信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls: local_dir: Input/output error</div></pre></td></tr></table></figure></p>
<p>取消挂载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">umount local_dir</div></pre></td></tr></table></figure></p>
<p>又会提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">umount: local_dir: not currently mounted</div></pre></td></tr></table></figure></p>
<p>这个时候, 我们不得不关闭进程了, 可以先通过命令查看进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pgrep -lf sshfs</div></pre></td></tr></table></figure></p>
<p>然后杀掉相应的挂载进程, 或者直接杀掉所有挂载进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pkill -9 sshfs</div></pre></td></tr></table></figure></p>
<p>之后重新挂载响应的目录即可</p>
<p>相关链接：<a href="http://www.jianshu.com/p/8723ba79f35a" target="_blank" rel="external">http://www.jianshu.com/p/8723ba79f35a</a></p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sshfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown 使用教程]]></title>
      <url>/2017/08/02/markdown-using-tutorial/</url>
      <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">不同数量的# 标题内容</div></pre></td></tr></table></figure></p>
<p>说明：在Markdown中，标题共计六个等级，标题字号随等级的升高而相应的降低。<br><a id="more"></a></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 一级标题</div><div class="line">## 二级标题</div><div class="line">### 三级标题</div><div class="line">#### 四级标题</div><div class="line">#####  五级标题</div><div class="line">######  六级标题</div></pre></td></tr></table></figure>
<p>示例显示效果：</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote>
<h1 id="斜体、粗体、加粗斜体、删除线"><a href="#斜体、粗体、加粗斜体、删除线" class="headerlink" title="斜体、粗体、加粗斜体、删除线"></a>斜体、粗体、加粗斜体、删除线</h1><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*斜体*</div><div class="line">**粗体**</div><div class="line">***加粗斜体***</div><div class="line">~~删除线~~</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p><em>斜体</em><br><strong>粗体</strong><br><strong><em>加粗斜体</em></strong><br><del>删除线</del></p>
</blockquote>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;链接地址&gt;</div></pre></td></tr></table></figure></p>
<p>说明：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，Markdown 就会自动把它转成链接。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;https://chengjinli.github.io/&gt;</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p><a href="https://chengjinli.github.io/" target="_blank" rel="external">https://chengjinli.github.io/</a></p>
</blockquote>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[链接文字](链接地址 &quot;链接标题&quot;)</div></pre></td></tr></table></figure></p>
<p>说明：()中的””之间可以为链接指定title，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title 文字。链接地址与链接标题前有一个空格。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[MJ&apos;s Learning Notes](https://chengjinli.github.io/)</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p><a href="https://chengjinli.github.io/" target="_blank" rel="external">MJ’s Learning Notes</a></p>
</blockquote>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">数字加一个英文句点</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. 有序列表1</div><div class="line">2. 有序列表2</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<ol>
<li>有序列表1</li>
<li>有序列表2</li>
</ol>
</blockquote>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*，+，- 加上列表内容</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">* 无序列表1</div><div class="line">* 无序列表2</div><div class="line">+ 无序列表3</div><div class="line">+ 无序列表4</div><div class="line">- 无序列表5</div><div class="line">- 无序列表6</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<ul>
<li>无序列表1</li>
<li>无序列表2</li>
</ul>
<ul>
<li>无序列表3</li>
<li>无序列表4</li>
</ul>
<ul>
<li>无序列表5</li>
<li>无序列表6</li>
</ul>
</blockquote>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="单层引用"><a href="#单层引用" class="headerlink" title="单层引用"></a>单层引用</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;加上被引用的内容</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; 一行内容的引用</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p>一行内容的引用</p>
</blockquote>
<h2 id="多层引用"><a href="#多层引用" class="headerlink" title="多层引用"></a>多层引用</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">不同数量的&gt;加上被引用的内容</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;第3层引用</div><div class="line"></div><div class="line">&gt;&gt;第2层引用</div><div class="line"></div><div class="line">&gt;第1层引用</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<blockquote>
<blockquote>
<p>第3层引用</p>
</blockquote>
<p>第2层引用</p>
</blockquote>
<p>第1层引用</p>
</blockquote>
<h2 id="引用其他元素"><a href="#引用其他元素" class="headerlink" title="引用其他元素"></a>引用其他元素</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; ### 三级标题</div><div class="line">&gt; 1. 第一行列表内容</div><div class="line">&gt; 2. 第二行列表内容</div><div class="line">&gt; </div><div class="line">&gt; 插入代码的例子</div><div class="line">&gt; `print (&quot;MJ&quot;)`</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<h3 id="三级标题-1"><a href="#三级标题-1" class="headerlink" title="三级标题"></a>三级标题</h3><ol>
<li>第一行列表内容</li>
<li>第二行列表内容</li>
</ol>
<p><code>print (&quot;MJ&quot;)</code></p>
</blockquote>
<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![图片Alt](图片地址 &quot;图片Title&quot;)</div></pre></td></tr></table></figure></p>
<p>说明：[]中写图片Alt，如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。()里写图片地址，()图片Title表示鼠标悬停在图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![头像](https://chengjinli.github.io/images/MJ.jpg &quot;MJ&quot;)</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p><img src="https://chengjinli.github.io/images/MJ.jpg" alt="头像" title="MJ"></p>
</blockquote>
<h1 id="LaTeX公式"><a href="#LaTeX公式" class="headerlink" title="LaTeX公式"></a>LaTeX公式</h1><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$公式$</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>
</blockquote>
<h2 id="正行公式"><a href="#正行公式" class="headerlink" title="正行公式"></a>正行公式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$公式$$</div></pre></td></tr></table></figure>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$$\sum_&#123;i=1&#125;^n a_i=0$$</div><div class="line">$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</div><div class="line">$$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$$</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p>$$\sum_{i=1}^n a_i=0$$</p>
<p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2$$</p>
</blockquote>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>语法说明：</p>
<ol>
<li>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。</li>
<li>列于列之间用管道符“|”隔开。原生方式的表格每一行的两边也要有管道符。</li>
<li>第二行还可以为不同的列指定对齐方向。默认为左对齐，在 “-” 右边加上 “:” 为右对齐，在 “-” 两侧同时加上 “:” 为居中对齐。</li>
</ol>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">|年|月|日|</div><div class="line">|-|:-:|-:|</div><div class="line">|2015|5|5|</div><div class="line">|2016|6|6|</div><div class="line">|2017|7|7|</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<table>
<thead>
<tr>
<th>年</th>
<th style="text-align:center">月</th>
<th style="text-align:right">日</th>
</tr>
</thead>
<tbody>
<tr>
<td>2015</td>
<td style="text-align:center">5</td>
<td style="text-align:right">5</td>
</tr>
<tr>
<td>2016</td>
<td style="text-align:center">6</td>
<td style="text-align:right">6</td>
</tr>
<tr>
<td>2017</td>
<td style="text-align:center">7</td>
<td style="text-align:right">7</td>
</tr>
</tbody>
</table>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>语法：<br>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* * *</div><div class="line">***</div><div class="line">*****</div><div class="line">- - -</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<hr>
<hr>
<hr>
<hr>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`代码`</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python语言里的函数`print()`怎么使用？</div></pre></td></tr></table></figure></p>
<p>示例显示效果：</p>
<blockquote>
<p>python语言里的函数<code>print()</code>怎么使用？</p>
</blockquote>
<h2 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h2><p>语法：<br>```<br>第1行代码<br>第2行代码<br>```</p>
<p>示例：<br>```python<br>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    print(“MJ”)<br>```</p>
<p>示例显示效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    print(<span class="string">"MJ"</span>)</div></pre></td></tr></table></figure></p>
<h2 id="缩进式代码"><a href="#缩进式代码" class="headerlink" title="缩进式代码"></a>缩进式代码</h2><p>语法：<br>缩进 4 个空格或是 1 个制表符，一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    print(<span class="string">"MJ"</span>)</div></pre></td></tr></table></figure></p>
<p>示例显示效果:</p>
<pre><code>if __name__ == &apos;__main__&apos;:
    print(&quot;MJ&quot;)
</code></pre><h1 id="相关链接："><a href="#相关链接：" class="headerlink" title="相关链接："></a>相关链接：</h1><p><a href="http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-6" target="_blank" rel="external">http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-6</a></p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Hexo + Next + github/coding 搭建个人静态博客]]></title>
      <url>/2017/08/01/use-hexo-next-github-and-coding-build-static-blog/</url>
      <content type="html"><![CDATA[<p>博客框架使用 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo</a><br>主题使用 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">NexT</a><br>代码托管使用 <a href="https://mart.coding.net/" target="_blank" rel="external">Coding</a><br><a id="more"></a></p>
<h1 id="Next主题修改文章内链接文本样式"><a href="#Next主题修改文章内链接文本样式" class="headerlink" title="Next主题修改文章内链接文本样式"></a>Next主题修改文章内链接文本样式</h1><p>实现效果：<br><a href="https://chengjin.li/" target="_blank" rel="external">https://chengjin.li/</a></p>
<p>在<code>themes\next\source\css\_common\components\post\post.styl</code>文件如下位置添加css样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.post-sticky-flag &#123;</div><div class="line">  display: inline-block;</div><div class="line">  font-size: 16px;</div><div class="line">  -ms-transform: rotate(30deg);</div><div class="line">  transform: rotate(30deg);</div><div class="line">&#125;</div><div class="line">// 文章内链接文本样式</div><div class="line">.post-body p a&#123;</div><div class="line">  color: #0593d3;</div><div class="line">  border-bottom: none;</div><div class="line">  &amp;:hover &#123;</div><div class="line">    color: #fc6423;</div><div class="line">    border-bottom: none;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Next主题添加鼠标心形点击特效"><a href="#Next主题添加鼠标心形点击特效" class="headerlink" title="Next主题添加鼠标心形点击特效"></a>Next主题添加鼠标心形点击特效</h1><p>1、 在<code>themes\next\source\js\src\</code>目录下新建<code>love.js</code>,代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</div></pre></td></tr></table></figure></p>
<p>2、 在<code>themes\next\layout\_layout.swig</code>文件的最下方，<code>&lt;/body&gt;</code>前面添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h1 id="Next主题修改文章底部的那个带-号的标签"><a href="#Next主题修改文章底部的那个带-号的标签" class="headerlink" title="Next主题修改文章底部的那个带#号的标签"></a>Next主题修改文章底部的那个带#号的标签</h1><p>实现效果：<br><img src="/images/label_modified_impression_drawing.png" alt="标签修改后的效果图"></p>
<p>方法：<br>修改模板<code>themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成 <code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h1 id="Next主题在每篇文章末尾统一添加“本文结束”标记"><a href="#Next主题在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="Next主题在每篇文章末尾统一添加“本文结束”标记"></a>Next主题在每篇文章末尾统一添加“本文结束”标记</h1><p>实现效果：<br><img src="/images/end_of_text.png" alt="本文结束标记"><br>方法：</p>
<p>在路径<code>themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件，并添加以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">    &#123;% if not is_index %&#125;</div><div class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</div><div class="line">    &#123;% endif %&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>接着打开<code>themes\next\layout\_macro\post.swig</code>文件，在 <code>post-body</code> 之后， <code>post-footer</code> 之前添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &#123;% if not is_index %&#125;</div><div class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</div><div class="line">  &#123;% endif %&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>然后打开主题配置文件<code>_config.yml</code>，在末尾添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 文章末尾添加“本文结束”标记</div><div class="line">passage_end_tag:</div><div class="line">  enabled: true</div></pre></td></tr></table></figure></p>
<h1 id="Next主题修改作者头像并旋转"><a href="#Next主题修改作者头像并旋转" class="headerlink" title="Next主题修改作者头像并旋转"></a>Next主题修改作者头像并旋转</h1><p>打开<code>themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code>，修改<code>site-author-image</code>相代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">.site-author-image &#123;</div><div class="line">  display: block;</div><div class="line">  margin: 0 auto;</div><div class="line">  padding: $site-author-image-padding;</div><div class="line">  max-width: $site-author-image-width;</div><div class="line">  height: $site-author-image-height;</div><div class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</div><div class="line"></div><div class="line">  /* 头像圆形 */</div><div class="line">  border-radius: 70px;</div><div class="line">  -webkit-border-radius: 70px;</div><div class="line">  -moz-border-radius: 70px;</div><div class="line">  box-shadow: inset 0 -1px 0 #333sf;</div><div class="line"></div><div class="line">  /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 </div><div class="line">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</div><div class="line"></div><div class="line"></div><div class="line">  /* 鼠标经过头像旋转360度 */</div><div class="line">  -webkit-transition: -webkit-transform 1.0s ease-out;</div><div class="line">  -moz-transition: -moz-transform 1.0s ease-out;</div><div class="line">  transition: transform 1.0s ease-out;</div><div class="line">&#125;</div><div class="line"></div><div class="line">img:hover &#123;</div><div class="line">  /* 鼠标经过停止头像旋转 </div><div class="line">  -webkit-animation-play-state:paused;</div><div class="line">  animation-play-state:paused;*/</div><div class="line"></div><div class="line">  /* 鼠标经过头像旋转360度 */</div><div class="line">  -webkit-transform: rotateZ(360deg);</div><div class="line">  -moz-transform: rotateZ(360deg);</div><div class="line">  transform: rotateZ(360deg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Z 轴旋转动画 */</div><div class="line">@-webkit-keyframes play &#123;</div><div class="line">  0% &#123;</div><div class="line">    -webkit-transform: rotateZ(0deg);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    -webkit-transform: rotateZ(-360deg);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">@-moz-keyframes play &#123;</div><div class="line">  0% &#123;</div><div class="line">    -moz-transform: rotateZ(0deg);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    -moz-transform: rotateZ(-360deg);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">@keyframes play &#123;</div><div class="line">  0% &#123;</div><div class="line">    transform: rotateZ(0deg);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    transform: rotateZ(-360deg);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Next主题设置网站的图标Favicon"><a href="#Next主题设置网站的图标Favicon" class="headerlink" title="Next主题设置网站的图标Favicon"></a>Next主题设置网站的图标Favicon</h1><p>方法：<br>将一张32x32的ico图标名称改为favicon.ico，然后把图标放在<code>themes/next/source/images</code>里，并且修改主题配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Put your favicon.ico into `hexo-site/source/` directory.</div><div class="line">favicon: /images/favicon.ico</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
